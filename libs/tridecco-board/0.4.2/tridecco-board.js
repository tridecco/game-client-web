/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Tridecco"] = factory();
	else
		root["Tridecco"] = factory();
})(self, () => {
return /******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./maps/board/default.js":
/*!*******************************!*\
  !*** ./maps/board/default.js ***!
  \*******************************/
/***/ ((module) => {

eval("/**\n * @fileoverview Default Map\n * @description The default map is the classic Tridecco map with 63 positions (11 columns and 10 rows with even-q type grid).\n */\n\nconst map = {\n  type: 'even-q',\n  columns: 11,\n  rows: 10,\n  positions: [\n    {\n      1: [1, 0, 6],\n      2: [1, 0, 5],\n      3: [0, 0, 3],\n      4: [0, 0, 4],\n      5: [1, 1, 6],\n      6: [1, 1, 1],\n      7: [1, 1, 2],\n      8: [1, 1, 3],\n      adjacents: [1, 8],\n      isEdge: true,\n    },\n    {\n      1: [3, 1, 1],\n      2: [3, 1, 6],\n      3: [2, 0, 4],\n      4: [2, 0, 5],\n      5: [2, 1, 1],\n      6: [2, 1, 2],\n      7: [2, 1, 3],\n      8: [2, 1, 4],\n      adjacents: [0, 2, 9, 10],\n      isEdge: true,\n    },\n    {\n      1: [4, 1, 2],\n      2: [4, 1, 1],\n      3: [4, 0, 5],\n      4: [4, 0, 6],\n      5: [3, 1, 2],\n      6: [3, 1, 3],\n      7: [3, 1, 4],\n      8: [3, 1, 5],\n      adjacents: [1, 3, 10, 11],\n      isEdge: true,\n    },\n    {\n      1: [5, 0, 6],\n      2: [5, 0, 5],\n      3: [4, 0, 3],\n      4: [4, 0, 4],\n      5: [5, 1, 6],\n      6: [5, 1, 1],\n      7: [5, 1, 2],\n      8: [5, 1, 3],\n      adjacents: [2, 4, 13],\n      isEdge: true,\n    },\n    {\n      1: [6, 1, 3],\n      2: [6, 1, 2],\n      3: [7, 1, 6],\n      4: [7, 1, 1],\n      5: [6, 0, 3],\n      6: [6, 0, 4],\n      7: [6, 0, 5],\n      8: [6, 0, 6],\n      adjacents: [3, 5, 13, 14],\n      isEdge: true,\n    },\n    {\n      1: [8, 1, 2],\n      2: [8, 1, 1],\n      3: [8, 0, 5],\n      4: [8, 0, 6],\n      5: [7, 1, 2],\n      6: [7, 1, 3],\n      7: [7, 1, 4],\n      8: [7, 1, 5],\n      adjacents: [4, 6, 14, 15],\n      isEdge: true,\n    },\n    {\n      1: [8, 1, 4],\n      2: [8, 1, 3],\n      3: [9, 2, 1],\n      4: [9, 2, 2],\n      5: [9, 1, 4],\n      6: [9, 1, 5],\n      7: [9, 1, 6],\n      8: [9, 1, 1],\n      adjacents: [5, 7, 15, 16],\n      isEdge: true,\n    },\n    {\n      1: [10, 1, 6],\n      2: [10, 1, 1],\n      3: [9, 1, 3],\n      4: [9, 1, 2],\n      5: [10, 0, 6],\n      6: [10, 0, 5],\n      7: [10, 0, 4],\n      8: [10, 0, 3],\n      adjacents: [6],\n      isEdge: true,\n    },\n    {\n      1: [1, 1, 4],\n      2: [1, 1, 5],\n      3: [1, 2, 1],\n      4: [1, 2, 6],\n      5: [0, 1, 4],\n      6: [0, 1, 3],\n      7: [0, 1, 2],\n      8: [0, 1, 1],\n      adjacents: [0, 9],\n      isEdge: true,\n    },\n    {\n      1: [2, 2, 2],\n      2: [2, 2, 1],\n      3: [2, 1, 5],\n      4: [2, 1, 6],\n      5: [1, 2, 2],\n      6: [1, 2, 3],\n      7: [1, 2, 4],\n      8: [1, 2, 5],\n      adjacents: [1, 8, 10, 17, 18],\n      isEdge: true,\n    },\n    {\n      1: [2, 2, 4],\n      2: [2, 2, 3],\n      3: [3, 3, 1],\n      4: [3, 3, 2],\n      5: [3, 2, 4],\n      6: [3, 2, 5],\n      7: [3, 2, 6],\n      8: [3, 2, 1],\n      adjacents: [1, 2, 9, 11, 18, 19],\n      isEdge: false,\n    },\n    {\n      1: [4, 2, 6],\n      2: [4, 2, 1],\n      3: [3, 2, 3],\n      4: [3, 2, 2],\n      5: [4, 1, 6],\n      6: [4, 1, 5],\n      7: [4, 1, 4],\n      8: [4, 1, 3],\n      adjacents: [2, 10, 12, 13],\n      isEdge: false,\n    },\n    {\n      1: [5, 3, 2],\n      2: [5, 3, 1],\n      3: [5, 2, 5],\n      4: [5, 2, 6],\n      5: [4, 2, 2],\n      6: [4, 2, 3],\n      7: [4, 2, 4],\n      8: [4, 2, 5],\n      adjacents: [11, 13, 19, 20, 21],\n      isEdge: false,\n    },\n    {\n      1: [6, 1, 1],\n      2: [6, 1, 6],\n      3: [5, 1, 4],\n      4: [5, 1, 5],\n      5: [5, 2, 1],\n      6: [5, 2, 2],\n      7: [5, 2, 3],\n      8: [5, 2, 4],\n      adjacents: [3, 4, 11, 12, 14, 21],\n      isEdge: false,\n    },\n    {\n      1: [6, 1, 5],\n      2: [6, 1, 4],\n      3: [6, 2, 2],\n      4: [6, 2, 3],\n      5: [7, 2, 5],\n      6: [7, 2, 6],\n      7: [7, 2, 1],\n      8: [7, 2, 2],\n      adjacents: [4, 5, 13, 15, 21, 22],\n      isEdge: false,\n    },\n    {\n      1: [8, 1, 6],\n      2: [8, 1, 5],\n      3: [7, 2, 3],\n      4: [7, 2, 4],\n      5: [8, 2, 6],\n      6: [8, 2, 1],\n      7: [8, 2, 2],\n      8: [8, 2, 3],\n      adjacents: [5, 6, 14, 16, 23, 24],\n      isEdge: false,\n    },\n    {\n      1: [9, 3, 3],\n      2: [9, 3, 2],\n      3: [10, 2, 6],\n      4: [10, 2, 1],\n      5: [9, 2, 3],\n      6: [9, 2, 4],\n      7: [9, 2, 5],\n      8: [9, 2, 6],\n      adjacents: [6, 15, 24, 25],\n      isEdge: true,\n    },\n    {\n      1: [0, 2, 5],\n      2: [0, 2, 4],\n      3: [0, 3, 2],\n      4: [0, 3, 3],\n      5: [1, 3, 5],\n      6: [1, 3, 6],\n      7: [1, 3, 1],\n      8: [1, 3, 2],\n      adjacents: [9, 18, 26],\n      isEdge: true,\n    },\n    {\n      1: [2, 2, 6],\n      2: [2, 2, 5],\n      3: [1, 3, 3],\n      4: [1, 3, 4],\n      5: [2, 3, 6],\n      6: [2, 3, 1],\n      7: [2, 3, 2],\n      8: [2, 3, 3],\n      adjacents: [9, 10, 17, 19, 26, 28],\n      isEdge: false,\n    },\n    {\n      1: [3, 4, 3],\n      2: [3, 4, 2],\n      3: [4, 3, 6],\n      4: [4, 3, 1],\n      5: [3, 3, 3],\n      6: [3, 3, 4],\n      7: [3, 3, 5],\n      8: [3, 3, 6],\n      adjacents: [10, 12, 18, 20, 28, 29],\n      isEdge: false,\n    },\n    {\n      1: [5, 4, 2],\n      2: [5, 4, 1],\n      3: [5, 3, 5],\n      4: [5, 3, 6],\n      5: [4, 3, 2],\n      6: [4, 3, 3],\n      7: [4, 3, 4],\n      8: [4, 3, 5],\n      adjacents: [12, 19, 21, 29, 30, 31],\n      isEdge: false,\n    },\n    {\n      1: [5, 3, 4],\n      2: [5, 3, 3],\n      3: [6, 3, 1],\n      4: [6, 3, 2],\n      5: [6, 2, 4],\n      6: [6, 2, 5],\n      7: [6, 2, 6],\n      8: [6, 2, 1],\n      adjacents: [12, 13, 14, 20, 22, 31],\n      isEdge: false,\n    },\n    {\n      1: [6, 3, 4],\n      2: [6, 3, 3],\n      3: [7, 4, 1],\n      4: [7, 4, 2],\n      5: [7, 3, 4],\n      6: [7, 3, 5],\n      7: [7, 3, 6],\n      8: [7, 3, 1],\n      adjacents: [14, 21, 23, 31, 32],\n      isEdge: false,\n    },\n    {\n      1: [7, 3, 2],\n      2: [7, 3, 3],\n      3: [8, 2, 5],\n      4: [8, 2, 4],\n      5: [8, 3, 2],\n      6: [8, 3, 1],\n      7: [8, 3, 6],\n      8: [8, 3, 5],\n      adjacents: [15, 22, 24, 32],\n      isEdge: false,\n    },\n    {\n      1: [8, 3, 4],\n      2: [8, 3, 3],\n      3: [9, 4, 1],\n      4: [9, 4, 2],\n      5: [9, 3, 4],\n      6: [9, 3, 5],\n      7: [9, 3, 6],\n      8: [9, 3, 1],\n      adjacents: [15, 16, 23, 25, 33],\n      isEdge: false,\n    },\n    {\n      1: [9, 4, 4],\n      2: [9, 4, 3],\n      3: [10, 4, 1],\n      4: [10, 4, 2],\n      5: [10, 3, 4],\n      6: [10, 3, 5],\n      7: [10, 3, 6],\n      8: [10, 3, 1],\n      adjacents: [16, 24, 33],\n      isEdge: true,\n    },\n    {\n      1: [0, 3, 5],\n      2: [0, 3, 4],\n      3: [0, 4, 2],\n      4: [0, 4, 3],\n      5: [1, 4, 5],\n      6: [1, 4, 6],\n      7: [1, 4, 1],\n      8: [1, 4, 2],\n      adjacents: [17, 18, 27],\n      isEdge: true,\n    },\n    {\n      1: [1, 4, 3],\n      2: [1, 4, 4],\n      3: [2, 4, 6],\n      4: [2, 4, 5],\n      5: [1, 5, 3],\n      6: [1, 5, 2],\n      7: [1, 5, 1],\n      8: [1, 5, 6],\n      adjacents: [26, 28, 35],\n      isEdge: true,\n    },\n    {\n      1: [3, 4, 1],\n      2: [3, 4, 6],\n      3: [2, 3, 4],\n      4: [2, 3, 5],\n      5: [2, 4, 1],\n      6: [2, 4, 2],\n      7: [2, 4, 3],\n      8: [2, 4, 4],\n      adjacents: [18, 19, 27, 29, 35, 36],\n      isEdge: false,\n    },\n    {\n      1: [3, 4, 5],\n      2: [3, 4, 4],\n      3: [3, 5, 2],\n      4: [3, 5, 3],\n      5: [4, 4, 5],\n      6: [4, 4, 6],\n      7: [4, 4, 1],\n      8: [4, 4, 2],\n      adjacents: [19, 20, 28, 30, 36, 38],\n      isEdge: false,\n    },\n    {\n      1: [5, 4, 6],\n      2: [5, 4, 5],\n      3: [4, 4, 3],\n      4: [4, 4, 4],\n      5: [5, 5, 6],\n      6: [5, 5, 1],\n      7: [5, 5, 2],\n      8: [5, 5, 3],\n      adjacents: [20, 29, 31, 38, 40],\n      isEdge: false,\n    },\n    {\n      1: [6, 3, 6],\n      2: [6, 3, 5],\n      3: [5, 4, 3],\n      4: [5, 4, 4],\n      5: [6, 4, 6],\n      6: [6, 4, 1],\n      7: [6, 4, 2],\n      8: [6, 4, 3],\n      adjacents: [20, 21, 22, 30, 32, 40],\n      isEdge: false,\n    },\n    {\n      1: [7, 5, 3],\n      2: [7, 5, 2],\n      3: [8, 4, 6],\n      4: [8, 4, 1],\n      5: [7, 4, 3],\n      6: [7, 4, 4],\n      7: [7, 4, 5],\n      8: [7, 4, 6],\n      adjacents: [22, 23, 31, 33, 40, 42],\n      isEdge: false,\n    },\n    {\n      1: [9, 5, 2],\n      2: [9, 5, 1],\n      3: [9, 4, 5],\n      4: [9, 4, 6],\n      5: [8, 4, 2],\n      6: [8, 4, 3],\n      7: [8, 4, 4],\n      8: [8, 4, 5],\n      adjacents: [24, 25, 32, 42, 44],\n      isEdge: true,\n    },\n    {\n      1: [0, 6, 3],\n      2: [0, 6, 2],\n      3: [1, 6, 6],\n      4: [1, 6, 1],\n      5: [0, 5, 3],\n      6: [0, 5, 4],\n      7: [0, 5, 5],\n      8: [0, 5, 6],\n      adjacents: [35, 45, 46],\n      isEdge: true,\n    },\n    {\n      1: [1, 5, 5],\n      2: [1, 5, 4],\n      3: [1, 6, 2],\n      4: [1, 6, 3],\n      5: [2, 5, 5],\n      6: [2, 5, 6],\n      7: [2, 5, 1],\n      8: [2, 5, 2],\n      adjacents: [27, 28, 34, 36, 46],\n      isEdge: false,\n    },\n    {\n      1: [2, 5, 4],\n      2: [2, 5, 3],\n      3: [3, 6, 1],\n      4: [3, 6, 2],\n      5: [3, 5, 4],\n      6: [3, 5, 5],\n      7: [3, 5, 6],\n      8: [3, 5, 1],\n      adjacents: [28, 29, 35, 37, 46, 47],\n      isEdge: false,\n    },\n    {\n      1: [4, 5, 6],\n      2: [4, 5, 5],\n      3: [3, 6, 3],\n      4: [3, 6, 4],\n      5: [4, 6, 6],\n      6: [4, 6, 1],\n      7: [4, 6, 2],\n      8: [4, 6, 3],\n      adjacents: [36, 38, 39, 47, 48],\n      isEdge: false,\n    },\n    {\n      1: [5, 5, 4],\n      2: [5, 5, 5],\n      3: [5, 6, 1],\n      4: [5, 6, 6],\n      5: [4, 5, 4],\n      6: [4, 5, 3],\n      7: [4, 5, 2],\n      8: [4, 5, 1],\n      adjacents: [29, 30, 37, 39],\n      isEdge: false,\n    },\n    {\n      1: [6, 6, 2],\n      2: [6, 6, 1],\n      3: [6, 5, 5],\n      4: [6, 5, 6],\n      5: [5, 6, 2],\n      6: [5, 6, 3],\n      7: [5, 6, 4],\n      8: [5, 6, 5],\n      adjacents: [37, 38, 40, 41, 48, 49],\n      isEdge: false,\n    },\n    {\n      1: [7, 5, 1],\n      2: [7, 5, 6],\n      3: [6, 4, 4],\n      4: [6, 4, 5],\n      5: [6, 5, 1],\n      6: [6, 5, 2],\n      7: [6, 5, 3],\n      8: [6, 5, 4],\n      adjacents: [30, 31, 32, 39, 41, 42],\n      isEdge: false,\n    },\n    {\n      1: [6, 6, 4],\n      2: [6, 6, 3],\n      3: [7, 7, 1],\n      4: [7, 7, 2],\n      5: [7, 6, 4],\n      6: [7, 6, 5],\n      7: [7, 6, 6],\n      8: [7, 6, 1],\n      adjacents: [39, 40, 42, 49, 50, 51],\n      isEdge: false,\n    },\n    {\n      1: [7, 5, 5],\n      2: [7, 5, 4],\n      3: [7, 6, 2],\n      4: [7, 6, 3],\n      5: [8, 5, 5],\n      6: [8, 5, 6],\n      7: [8, 5, 1],\n      8: [8, 5, 2],\n      adjacents: [32, 33, 40, 41, 43, 44],\n      isEdge: false,\n    },\n    {\n      1: [8, 6, 1],\n      2: [8, 6, 2],\n      3: [8, 5, 4],\n      4: [8, 5, 3],\n      5: [9, 6, 1],\n      6: [9, 6, 6],\n      7: [9, 6, 5],\n      8: [9, 6, 4],\n      adjacents: [42, 44, 51, 52],\n      isEdge: false,\n    },\n    {\n      1: [9, 6, 3],\n      2: [9, 6, 2],\n      3: [10, 5, 6],\n      4: [10, 5, 1],\n      5: [9, 5, 3],\n      6: [9, 5, 4],\n      7: [9, 5, 5],\n      8: [9, 5, 6],\n      adjacents: [33, 42, 43],\n      isEdge: true,\n    },\n    {\n      1: [1, 7, 1],\n      2: [1, 7, 6],\n      3: [0, 6, 4],\n      4: [0, 6, 5],\n      5: [0, 7, 1],\n      6: [0, 7, 2],\n      7: [0, 7, 3],\n      8: [0, 7, 4],\n      adjacents: [34, 46, 53, 54],\n      isEdge: true,\n    },\n    {\n      1: [1, 6, 5],\n      2: [1, 6, 4],\n      3: [1, 7, 2],\n      4: [1, 7, 3],\n      5: [2, 6, 5],\n      6: [2, 6, 6],\n      7: [2, 6, 1],\n      8: [2, 6, 2],\n      adjacents: [34, 35, 36, 45, 47, 54],\n      isEdge: false,\n    },\n    {\n      1: [3, 6, 6],\n      2: [3, 6, 5],\n      3: [2, 6, 3],\n      4: [2, 6, 4],\n      5: [3, 7, 6],\n      6: [3, 7, 1],\n      7: [3, 7, 2],\n      8: [3, 7, 3],\n      adjacents: [36, 37, 46, 48, 55, 56],\n      isEdge: false,\n    },\n    {\n      1: [4, 6, 5],\n      2: [4, 6, 4],\n      3: [4, 7, 2],\n      4: [4, 7, 3],\n      5: [5, 7, 5],\n      6: [5, 7, 6],\n      7: [5, 7, 1],\n      8: [5, 7, 2],\n      adjacents: [37, 39, 47, 49, 56, 57],\n      isEdge: false,\n    },\n    {\n      1: [6, 6, 6],\n      2: [6, 6, 5],\n      3: [5, 7, 3],\n      4: [5, 7, 4],\n      5: [6, 7, 6],\n      6: [6, 7, 1],\n      7: [6, 7, 2],\n      8: [6, 7, 3],\n      adjacents: [39, 41, 48, 50, 58, 59],\n      isEdge: false,\n    },\n    {\n      1: [7, 8, 3],\n      2: [7, 8, 2],\n      3: [8, 7, 6],\n      4: [8, 7, 1],\n      5: [7, 7, 3],\n      6: [7, 7, 4],\n      7: [7, 7, 5],\n      8: [7, 7, 6],\n      adjacents: [41, 49, 51, 59, 60, 61],\n      isEdge: false,\n    },\n    {\n      1: [8, 7, 3],\n      2: [8, 7, 2],\n      3: [9, 7, 6],\n      4: [9, 7, 1],\n      5: [8, 6, 3],\n      6: [8, 6, 4],\n      7: [8, 6, 5],\n      8: [8, 6, 6],\n      adjacents: [41, 43, 50, 52, 61],\n      isEdge: false,\n    },\n    {\n      1: [10, 7, 2],\n      2: [10, 7, 1],\n      3: [10, 6, 5],\n      4: [10, 6, 6],\n      5: [9, 7, 2],\n      6: [9, 7, 3],\n      7: [9, 7, 4],\n      8: [9, 7, 5],\n      adjacents: [43, 51, 61, 62],\n      isEdge: true,\n    },\n    {\n      1: [1, 8, 6],\n      2: [1, 8, 5],\n      3: [0, 8, 3],\n      4: [0, 8, 4],\n      5: [1, 9, 6],\n      6: [1, 9, 1],\n      7: [1, 9, 2],\n      8: [1, 9, 3],\n      adjacents: [45, 54],\n      isEdge: true,\n    },\n    {\n      1: [2, 7, 1],\n      2: [2, 7, 6],\n      3: [1, 7, 4],\n      4: [1, 7, 5],\n      5: [1, 8, 1],\n      6: [1, 8, 2],\n      7: [1, 8, 3],\n      8: [1, 8, 4],\n      adjacents: [45, 46, 53, 55],\n      isEdge: true,\n    },\n    {\n      1: [3, 8, 5],\n      2: [3, 8, 6],\n      3: [2, 8, 2],\n      4: [2, 8, 3],\n      5: [2, 7, 5],\n      6: [2, 7, 4],\n      7: [2, 7, 3],\n      8: [2, 7, 2],\n      adjacents: [47, 54, 56],\n      isEdge: true,\n    },\n    {\n      1: [4, 7, 1],\n      2: [4, 7, 6],\n      3: [3, 7, 4],\n      4: [3, 7, 5],\n      5: [3, 8, 1],\n      6: [3, 8, 2],\n      7: [3, 8, 3],\n      8: [3, 8, 4],\n      adjacents: [47, 48, 55, 57],\n      isEdge: true,\n    },\n    {\n      1: [5, 8, 1],\n      2: [5, 8, 6],\n      3: [4, 7, 4],\n      4: [4, 7, 5],\n      5: [4, 8, 1],\n      6: [4, 8, 2],\n      7: [4, 8, 3],\n      8: [4, 8, 4],\n      adjacents: [48, 56, 58],\n      isEdge: true,\n    },\n    {\n      1: [6, 8, 5],\n      2: [6, 8, 6],\n      3: [5, 9, 2],\n      4: [5, 9, 1],\n      5: [5, 8, 5],\n      6: [5, 8, 4],\n      7: [5, 8, 3],\n      8: [5, 8, 2],\n      adjacents: [49, 57, 59],\n      isEdge: true,\n    },\n    {\n      1: [7, 8, 1],\n      2: [7, 8, 6],\n      3: [6, 7, 4],\n      4: [6, 7, 5],\n      5: [6, 8, 1],\n      6: [6, 8, 2],\n      7: [6, 8, 3],\n      8: [6, 8, 4],\n      adjacents: [49, 50, 58, 60],\n      isEdge: true,\n    },\n    {\n      1: [8, 8, 1],\n      2: [8, 8, 6],\n      3: [7, 8, 4],\n      4: [7, 8, 5],\n      5: [7, 9, 1],\n      6: [7, 9, 2],\n      7: [7, 9, 3],\n      8: [7, 9, 4],\n      adjacents: [50, 59, 61],\n      isEdge: true,\n    },\n    {\n      1: [8, 7, 5],\n      2: [8, 7, 4],\n      3: [8, 8, 2],\n      4: [8, 8, 3],\n      5: [9, 8, 5],\n      6: [9, 8, 6],\n      7: [9, 8, 1],\n      8: [9, 8, 2],\n      adjacents: [50, 51, 52, 60, 62],\n      isEdge: true,\n    },\n    {\n      1: [10, 7, 6],\n      2: [10, 7, 5],\n      3: [9, 8, 3],\n      4: [9, 8, 4],\n      5: [10, 8, 6],\n      6: [10, 8, 1],\n      7: [10, 8, 2],\n      8: [10, 8, 3],\n      adjacents: [52, 61],\n      isEdge: true,\n    },\n  ],\n};\n\nmodule.exports = map;\n\n\n//# sourceURL=webpack://Tridecco/./maps/board/default.js?");

/***/ }),

/***/ "./maps/renderer/default.js":
/*!**********************************!*\
  !*** ./maps/renderer/default.js ***!
  \**********************************/
/***/ ((module) => {

eval("/**\n * @fileoverview Default Renderer Map\n * @description This file contains the default renderer map for the Tridecco game.\n */\n\nconst map = {\n  height: 1000,\n  width: 1000,\n  tiles: [\n    {\n      x: 55,\n      y: 62,\n      width: 160,\n      rotation: 60,\n      flipped: false,\n    },\n    {\n      x: 180,\n      y: 99,\n      width: 160,\n      rotation: 120,\n      flipped: false,\n    },\n    {\n      x: 294,\n      y: 81,\n      width: 160,\n      rotation: 180,\n      flipped: false,\n    },\n    {\n      x: 388,\n      y: 63,\n      width: 160,\n      rotation: 60,\n      flipped: false,\n    },\n    {\n      x: 532,\n      y: 76,\n      width: 160,\n      rotation: 240,\n      flipped: false,\n    },\n    {\n      x: 628,\n      y: 82,\n      width: 160,\n      rotation: 180,\n      flipped: false,\n    },\n    {\n      x: 741,\n      y: 135,\n      width: 160,\n      rotation: 300,\n      flipped: false,\n    },\n    {\n      x: 805,\n      y: 76,\n      width: 160,\n      rotation: 120,\n      flipped: true,\n    },\n    {\n      x: 45,\n      y: 152,\n      width: 160,\n      rotation: 0,\n      flipped: true,\n    },\n    {\n      x: 126,\n      y: 178,\n      width: 160,\n      rotation: 180,\n      flipped: false,\n    },\n    {\n      x: 240,\n      y: 232,\n      width: 160,\n      rotation: 300,\n      flipped: false,\n    },\n    {\n      x: 306,\n      y: 173,\n      width: 160,\n      rotation: 120,\n      flipped: true,\n    },\n    {\n      x: 377,\n      y: 227,\n      width: 160,\n      rotation: 180,\n      flipped: false,\n    },\n    {\n      x: 430,\n      y: 148,\n      width: 160,\n      rotation: 120,\n      flipped: false,\n    },\n    {\n      x: 543,\n      y: 200,\n      width: 160,\n      rotation: 0,\n      flipped: false,\n    },\n    {\n      x: 638,\n      y: 208,\n      width: 160,\n      rotation: 60,\n      flipped: false,\n    },\n    {\n      x: 781,\n      y: 220,\n      width: 160,\n      rotation: 240,\n      flipped: false,\n    },\n    {\n      x: 44,\n      y: 297,\n      width: 160,\n      rotation: 0,\n      flipped: false,\n    },\n    {\n      x: 139,\n      y: 304,\n      width: 160,\n      rotation: 60,\n      flipped: false,\n    },\n    {\n      x: 281,\n      y: 317,\n      width: 160,\n      rotation: 240,\n      flipped: false,\n    },\n    {\n      x: 378,\n      y: 324,\n      width: 160,\n      rotation: 180,\n      flipped: false,\n    },\n    {\n      x: 490,\n      y: 280,\n      width: 160,\n      rotation: 300,\n      flipped: false,\n    },\n    {\n      x: 573,\n      y: 327,\n      width: 160,\n      rotation: 300,\n      flipped: false,\n    },\n    {\n      x: 657,\n      y: 293,\n      width: 160,\n      rotation: 240,\n      flipped: true,\n    },\n    {\n      x: 740,\n      y: 326,\n      width: 160,\n      rotation: 300,\n      flipped: false,\n    },\n    {\n      x: 823,\n      y: 376,\n      width: 160,\n      rotation: 300,\n      flipped: false,\n    },\n    {\n      x: 45,\n      y: 393,\n      width: 160,\n      rotation: 0,\n      flipped: false,\n    },\n    {\n      x: 118,\n      y: 448,\n      width: 160,\n      rotation: 300,\n      flipped: true,\n    },\n    {\n      x: 181,\n      y: 390,\n      width: 160,\n      rotation: 120,\n      flipped: false,\n    },\n    {\n      x: 295,\n      y: 441,\n      width: 160,\n      rotation: 0,\n      flipped: false,\n    },\n    {\n      x: 388,\n      y: 448,\n      width: 160,\n      rotation: 60,\n      flipped: false,\n    },\n    {\n      x: 472,\n      y: 400,\n      width: 160,\n      rotation: 60,\n      flipped: false,\n    },\n    {\n      x: 614,\n      y: 413,\n      width: 160,\n      rotation: 240,\n      flipped: false,\n    },\n    {\n      x: 710,\n      y: 419,\n      width: 160,\n      rotation: 180,\n      flipped: false,\n    },\n    {\n      x: 34,\n      y: 558,\n      width: 160,\n      rotation: 240,\n      flipped: false,\n    },\n    {\n      x: 130,\n      y: 538,\n      width: 160,\n      rotation: 0,\n      flipped: false,\n    },\n    {\n      x: 243,\n      y: 520,\n      width: 160,\n      rotation: 300,\n      flipped: false,\n    },\n    {\n      x: 307,\n      y: 592,\n      width: 160,\n      rotation: 60,\n      flipped: false,\n    },\n    {\n      x: 377,\n      y: 538,\n      width: 160,\n      rotation: 0,\n      flipped: true,\n    },\n    {\n      x: 461,\n      y: 563,\n      width: 160,\n      rotation: 180,\n      flipped: false,\n    },\n    {\n      x: 512,\n      y: 485,\n      width: 160,\n      rotation: 120,\n      flipped: false,\n    },\n    {\n      x: 575,\n      y: 616,\n      width: 160,\n      rotation: 300,\n      flipped: false,\n    },\n    {\n      x: 627,\n      y: 538,\n      width: 160,\n      rotation: 0,\n      flipped: false,\n    },\n    {\n      x: 711,\n      y: 564,\n      width: 160,\n      rotation: 180,\n      flipped: true,\n    },\n    {\n      x: 781,\n      y: 509,\n      width: 160,\n      rotation: 240,\n      flipped: false,\n    },\n    {\n      x: 15,\n      y: 678,\n      width: 160,\n      rotation: 120,\n      flipped: false,\n    },\n    {\n      x: 129,\n      y: 634,\n      width: 160,\n      rotation: 0,\n      flipped: false,\n    },\n    {\n      x: 225,\n      y: 640,\n      width: 160,\n      rotation: 60,\n      flipped: false,\n    },\n    {\n      x: 378,\n      y: 682,\n      width: 160,\n      rotation: 0,\n      flipped: false,\n    },\n    {\n      x: 472,\n      y: 688,\n      width: 160,\n      rotation: 60,\n      flipped: false,\n    },\n    {\n      x: 617,\n      y: 701,\n      width: 160,\n      rotation: 240,\n      flipped: false,\n    },\n    {\n      x: 700,\n      y: 653,\n      width: 160,\n      rotation: 240,\n      flipped: false,\n    },\n    {\n      x: 793,\n      y: 660,\n      width: 160,\n      rotation: 180,\n      flipped: false,\n    },\n    {\n      x: 58,\n      y: 832,\n      width: 160,\n      rotation: 60,\n      flipped: false,\n    },\n    {\n      x: 100,\n      y: 726,\n      width: 160,\n      rotation: 120,\n      flipped: false,\n    },\n    {\n      x: 182,\n      y: 760,\n      width: 160,\n      rotation: 60,\n      flipped: true,\n    },\n    {\n      x: 265,\n      y: 726,\n      width: 160,\n      rotation: 120,\n      flipped: false,\n    },\n    {\n      x: 348,\n      y: 774,\n      width: 160,\n      rotation: 120,\n      flipped: false,\n    },\n    {\n      x: 430,\n      y: 808,\n      width: 160,\n      rotation: 60,\n      flipped: true,\n    },\n    {\n      x: 513,\n      y: 773,\n      width: 160,\n      rotation: 120,\n      flipped: false,\n    },\n    {\n      x: 598,\n      y: 822,\n      width: 160,\n      rotation: 120,\n      flipped: false,\n    },\n    {\n      x: 710,\n      y: 777,\n      width: 160,\n      rotation: 0,\n      flipped: false,\n    },\n    {\n      x: 806,\n      y: 785,\n      width: 160,\n      rotation: 60,\n      flipped: false,\n    },\n  ],\n  hexagons: {\n    '1-1': {\n      x: 111,\n      y: 103,\n      width: 110,\n    },\n    '1-2': {\n      x: 111,\n      y: 201,\n      width: 110,\n    },\n    '1-3': {\n      x: 111,\n      y: 297,\n      width: 110,\n    },\n    '1-4': {\n      x: 111,\n      y: 393,\n      width: 110,\n    },\n    '1-5': {\n      x: 111,\n      y: 489,\n      width: 110,\n    },\n    '1-6': {\n      x: 111,\n      y: 586,\n      width: 110,\n    },\n    '1-7': {\n      x: 111,\n      y: 681,\n      width: 110,\n    },\n    '1-8': {\n      x: 111,\n      y: 778,\n      width: 110,\n    },\n    '1-9': {\n      x: 111,\n      y: 872,\n      width: 110,\n    },\n    '2-1': {\n      x: 194,\n      y: 152,\n      width: 110,\n    },\n    '2-2': {\n      x: 194,\n      y: 248,\n      width: 110,\n    },\n    '2-3': {\n      x: 194,\n      y: 344,\n      width: 110,\n    },\n    '2-4': {\n      x: 194,\n      y: 441,\n      width: 110,\n    },\n    '2-5': {\n      x: 194,\n      y: 537,\n      width: 110,\n    },\n    '2-6': {\n      x: 194,\n      y: 634,\n      width: 110,\n    },\n    '2-7': {\n      x: 194,\n      y: 730,\n      width: 110,\n    },\n    '3-1': {\n      x: 277,\n      y: 104,\n      width: 110,\n    },\n    '3-2': {\n      x: 277,\n      y: 200,\n      width: 110,\n    },\n    '3-3': {\n      x: 277,\n      y: 296,\n      width: 110,\n    },\n    '3-4': {\n      x: 277,\n      y: 393,\n      width: 110,\n    },\n    '3-5': {\n      x: 277,\n      y: 489,\n      width: 110,\n    },\n    '3-6': {\n      x: 277,\n      y: 586,\n      width: 110,\n    },\n    '3-7': {\n      x: 277,\n      y: 681,\n      width: 110,\n    },\n    '3-8': {\n      x: 277,\n      y: 778,\n      width: 110,\n    },\n    '4-1': {\n      x: 360,\n      y: 152,\n      width: 110,\n    },\n    '4-2': {\n      x: 360,\n      y: 248,\n      width: 110,\n    },\n    '4-3': {\n      x: 360,\n      y: 344,\n      width: 110,\n    },\n    '4-4': {\n      x: 360,\n      y: 441,\n      width: 110,\n    },\n    '4-5': {\n      x: 360,\n      y: 537,\n      width: 110,\n    },\n    '4-6': {\n      x: 360,\n      y: 634,\n      width: 110,\n    },\n    '4-7': {\n      x: 360,\n      y: 730,\n      width: 110,\n    },\n    '5-1': {\n      x: 443,\n      y: 104,\n      width: 110,\n    },\n    '5-2': {\n      x: 443,\n      y: 200,\n      width: 110,\n    },\n    '5-3': {\n      x: 443,\n      y: 296,\n      width: 110,\n    },\n    '5-4': {\n      x: 443,\n      y: 393,\n      width: 110,\n    },\n    '5-5': {\n      x: 443,\n      y: 489,\n      width: 110,\n    },\n    '5-6': {\n      x: 443,\n      y: 586,\n      width: 110,\n    },\n    '5-7': {\n      x: 443,\n      y: 681,\n      width: 110,\n    },\n    '5-8': {\n      x: 443,\n      y: 778,\n      width: 110,\n    },\n    '6-1': {\n      x: 526,\n      y: 152,\n      width: 110,\n    },\n    '6-2': {\n      x: 526,\n      y: 248,\n      width: 110,\n    },\n    '6-3': {\n      x: 526,\n      y: 344,\n      width: 110,\n    },\n    '6-4': {\n      x: 526,\n      y: 441,\n      width: 110,\n    },\n    '6-5': {\n      x: 526,\n      y: 537,\n      width: 110,\n    },\n    '6-6': {\n      x: 526,\n      y: 634,\n      width: 110,\n    },\n    '6-7': {\n      x: 526,\n      y: 730,\n      width: 110,\n    },\n    '6-8': {\n      x: 526,\n      y: 826,\n      width: 110,\n    },\n    '7-1': {\n      x: 609,\n      y: 104,\n      width: 110,\n    },\n    '7-2': {\n      x: 609,\n      y: 200,\n      width: 110,\n    },\n    '7-3': {\n      x: 609,\n      y: 296,\n      width: 110,\n    },\n    '7-4': {\n      x: 609,\n      y: 393,\n      width: 110,\n    },\n    '7-5': {\n      x: 609,\n      y: 489,\n      width: 110,\n    },\n    '7-6': {\n      x: 609,\n      y: 586,\n      width: 110,\n    },\n    '7-7': {\n      x: 609,\n      y: 681,\n      width: 110,\n    },\n    '7-8': {\n      x: 609,\n      y: 778,\n      width: 110,\n    },\n    '8-1': {\n      x: 693,\n      y: 152,\n      width: 110,\n    },\n    '8-2': {\n      x: 693,\n      y: 248,\n      width: 110,\n    },\n    '8-3': {\n      x: 693,\n      y: 344,\n      width: 110,\n    },\n    '8-4': {\n      x: 693,\n      y: 441,\n      width: 110,\n    },\n    '8-5': {\n      x: 693,\n      y: 537,\n      width: 110,\n    },\n    '8-6': {\n      x: 693,\n      y: 634,\n      width: 110,\n    },\n    '8-7': {\n      x: 693,\n      y: 730,\n      width: 110,\n    },\n    '9-1': {\n      x: 776,\n      y: 104,\n      width: 110,\n    },\n    '9-2': {\n      x: 776,\n      y: 200,\n      width: 110,\n    },\n    '9-3': {\n      x: 776,\n      y: 296,\n      width: 110,\n    },\n    '9-4': {\n      x: 776,\n      y: 393,\n      width: 110,\n    },\n    '9-5': {\n      x: 776,\n      y: 489,\n      width: 110,\n    },\n    '9-6': {\n      x: 776,\n      y: 586,\n      width: 110,\n    },\n    '9-7': {\n      x: 776,\n      y: 681,\n      width: 110,\n    },\n    '9-8': {\n      x: 776,\n      y: 778,\n      width: 110,\n    },\n  },\n};\n\nmodule.exports = map;\n\n\n//# sourceURL=webpack://Tridecco/./maps/renderer/default.js?");

/***/ }),

/***/ "./src/board.js":
/*!**********************!*\
  !*** ./src/board.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Game Board\n * @description This file contains the implementation of the Tridecco game board.\n */\n\nconst deepClone = __webpack_require__(/*! ./utils/deepClone */ \"./src/utils/deepClone.js\");\n\nconst TriHexGrid = __webpack_require__(/*! ./triHexGrid */ \"./src/triHexGrid.js\");\nconst Piece = __webpack_require__(/*! ./piece */ \"./src/piece.js\");\n\nconst defaultMap = __webpack_require__(/*! ../maps/board/default */ \"./maps/board/default.js\");\n\n/**\n * @class Board - A class representing the game board.\n */\nclass Board {\n  /**\n   * @constructor\n   * @param {Object} map - The map object containing the board configuration and positions.\n   * @throws {Error} - Throws an error if the map is invalid or not provided.\n   */\n  constructor(map = defaultMap) {\n    if (!map) {\n      throw new Error('Map is required to initialize the board');\n    }\n\n    if (!map || !map.type || !map.columns || !map.rows || !map.positions) {\n      throw new Error('Invalid map provided');\n    }\n\n    this.map = map;\n    this.grid = new TriHexGrid(map.columns, map.rows, map.type);\n    this.indexes = new Array(map.positions.length).fill(null); // Initialize indexes to null\n\n    this.hexagons = new Set();\n    this.hexagonColors = new Map(); // Map to store hexagon colors\n\n    this.eventListeners = {\n      set: new Set(), // Listeners for set events\n      remove: new Set(), // Listeners for remove events\n      form: new Set(), // Listeners for form events (when a hexagon is formed)\n      destroy: new Set(), // Listeners for destroy events (when a hexagon is destroyed)\n      clear: new Set(), // Listeners for clear events (when the board is cleared)\n    };\n    this._isCountingHexagons = false; // Flag to prevent event triggering during hexagon counting\n\n    this.history = new Array();\n  }\n\n  /**\n   * @property {Object} POSITION_INDEXES - The indexes for the position in the map.\n   */\n  static POSITION_INDEXES = {\n    A: 1,\n    B: 2,\n    C: 3,\n    D: 4,\n    E: 5,\n    F: 6,\n    G: 7,\n    H: 8,\n  };\n\n  /**\n   * @method _triggerEvent - Trigger an event for a specific action.\n   * @param {string} eventType - The type of event to trigger (set, remove, form, destroy, clear).\n   * @param {...any} args - The arguments to pass to the event listeners.\n   */\n  _triggerEvent(eventType, ...args) {\n    if (this.eventListeners[eventType]) {\n      if (this._isCountingHexagons) {\n        // Prevent triggering events when counting hexagons\n        return;\n      }\n\n      this.eventListeners[eventType].forEach((listener) => {\n        listener(...args);\n      });\n    }\n  }\n\n  /**\n   * @method get - Get the value at the specified position in the map.\n   * @param {number} index - The index of the position in the map. (0-based index)\n   * @returns {Piece} - The value at the specified position or null if not found.\n   * @throws {Error} - Throws an error if the index is out of bounds.\n   */\n  get(index) {\n    if (index < 0 || index >= this.map.positions.length) {\n      throw new Error('Index out of bounds');\n    }\n\n    return this.indexes[index];\n  }\n\n  /**\n   * @method set - Set the value at the specified position in the map.\n   * @param {number} index - The index of the position in the map. (0-based index)\n   * @param {Piece} value - The value to set at the specified position.\n   * @throws {Error} - Throws an error if the index is out of bounds or if the value is not an instance of Piece.\n   */\n  set(index, value) {\n    if (index < 0 || index >= this.map.positions.length) {\n      throw new Error('Index out of bounds');\n    }\n\n    if (!(value instanceof Piece)) {\n      throw new Error('Value must be an instance of Piece');\n    }\n\n    const position = this.map.positions[index];\n\n    this.indexes[index] = value;\n\n    const relatedHexagons = this.getRelatedHexagons(index);\n\n    this.grid.set(\n      [\n        position[Board.POSITION_INDEXES.A],\n        position[Board.POSITION_INDEXES.B],\n        position[Board.POSITION_INDEXES.C],\n        position[Board.POSITION_INDEXES.D],\n      ],\n      value.colors[0],\n    );\n    this.grid.set(\n      [\n        position[Board.POSITION_INDEXES.E],\n        position[Board.POSITION_INDEXES.F],\n        position[Board.POSITION_INDEXES.G],\n        position[Board.POSITION_INDEXES.H],\n      ],\n      value.colors[1],\n    );\n\n    relatedHexagons.forEach((hexagon) => {\n      const [col, row] = hexagon.split('-').map(Number);\n      if (this.isCompleteHexagon(col, row)) {\n        this.hexagons.add(`${col}-${row}`);\n        this.hexagonColors.set(\n          `${col}-${row}`,\n          this.grid.getHexagon(col, row)[0],\n        );\n      }\n    });\n\n    this.history.push({\n      op: 'set',\n      index: index,\n    });\n\n    this._triggerEvent('set', index, value); // Trigger set event\n  }\n\n  /**\n   * @method place - Place a piece at the specified position in the map.\n   * @param {number} index - The index of the position in the map. (0-based index)\n   * @param {Piece} value - The piece to place at the specified position.\n   * @returns {Array<Object>} - An array of objects representing the hexagons formed, each with coordinate and color.\n   * @throws {Error} - Throws an error if the index is out of bounds, the position is occupied, or the value is not an instance of Piece.\n   */\n  place(index, value) {\n    if (index < 0 || index >= this.map.positions.length) {\n      throw new Error('Index out of bounds');\n    }\n\n    if (this.indexes[index]) {\n      throw new Error('Position already occupied');\n    }\n\n    if (!(value instanceof Piece)) {\n      throw new Error('Value must be an instance of Piece');\n    }\n\n    const hexagonsBefore = new Set(this.hexagons);\n\n    this.set(index, value);\n\n    const newHexagons = Array.from(this.hexagons).filter(\n      (hexagon) => !hexagonsBefore.has(hexagon),\n    );\n\n    const hexagonsFormed = newHexagons.map((hexagon) => {\n      return {\n        coordinate: hexagon.split('-').map(Number),\n        color: this.hexagonColors.get(hexagon), // Get the color of the hexagon\n      };\n    });\n\n    if (newHexagons.length > 0) {\n      // If new hexagons are formed, trigger the form event\n      this._triggerEvent('form', hexagonsFormed); // Trigger form event for new hexagons formed\n    }\n\n    return hexagonsFormed;\n  }\n\n  /**\n   * @method remove - Remove the value at the specified position in the map.\n   * @param {number} index - The index of the position in the map. (0-based index)\n   * @returns {Piece} - The removed value at the specified position or null if not found.\n   * @throws {Error} - Throws an error if the index is out of bounds.\n   */\n  remove(index) {\n    if (index < 0 || index >= this.map.positions.length) {\n      throw new Error('Index out of bounds');\n    }\n\n    const position = this.map.positions[index];\n\n    const relatedHexagons = this.getRelatedHexagons(index);\n\n    const removedHexagons = relatedHexagons.filter((hexagon) => {\n      if (this.hexagons.has(hexagon)) {\n        return true;\n      }\n      return false;\n    });\n\n    this.grid.remove([\n      position[Board.POSITION_INDEXES.A],\n      position[Board.POSITION_INDEXES.B],\n      position[Board.POSITION_INDEXES.C],\n      position[Board.POSITION_INDEXES.D],\n      position[Board.POSITION_INDEXES.E],\n      position[Board.POSITION_INDEXES.F],\n      position[Board.POSITION_INDEXES.G],\n      position[Board.POSITION_INDEXES.H],\n    ]);\n\n    removedHexagons.forEach((hexagon) => {\n      this.hexagons.delete(hexagon); // Remove the hexagon from the set\n      this.hexagonColors.delete(hexagon); // Remove the color of the hexagon\n    });\n\n    // Trigger destroy event for all removed hexagons\n    this._triggerEvent(\n      'destroy',\n      removedHexagons.map((hexagon) => hexagon.split('-').map(Number)),\n    );\n\n    const removedValue = this.indexes[index];\n\n    this.history.push({\n      op: 'remove',\n      index: index,\n      value: removedValue,\n    });\n\n    this.indexes[index] = null;\n\n    this._triggerEvent('remove', index, removedValue); // Trigger remove event\n\n    return removedValue;\n  }\n\n  /**\n   * @method getRelatedHexagons - Get all the related hexagons for a given position.\n   * @param {number} index - The index of the position in the map. (0-based index)\n   * @returns {Array<string>} - An array of related hexagons, each represented as a string in the format \"col-row\" (key).\n   * @throws {Error} - Throws an error if the index is out of bounds.\n   */\n  getRelatedHexagons(index) {\n    if (index < 0 || index >= this.map.positions.length) {\n      throw new Error('Index out of bounds');\n    }\n\n    const position = this.map.positions[index];\n\n    const hexagons = new Set();\n    for (let i = 1; i <= Board.POSITION_INDEXES.F; i++) {\n      const hexagon = position[i];\n      if (hexagon) {\n        const hexagonKey = `${hexagon[0]}-${hexagon[1]}`;\n        hexagons.add(hexagonKey);\n      }\n    }\n\n    return Array.from(hexagons);\n  }\n\n  /**\n   * @method getRandomPosition - Get a random position from the map.\n   * @param {boolean} [isEdge=false] - Whether to include edge positions.\n   * @param {Array} [excludedIndexes=[]] - An array of indexes to exclude from the random selection.\n   * @returns {number} - A random index from the map. If no valid position is found, returns -1.\n   */\n  getRandomPosition(isEdge = false, excludedIndexes = []) {\n    const excludedSet = new Set(excludedIndexes);\n    const validIndexes = [];\n\n    this.map.positions.forEach((position, index) => {\n      if (!excludedSet.has(index) && (isEdge || !position.isEdge)) {\n        validIndexes.push(index);\n      }\n    });\n\n    if (validIndexes.length === 0) {\n      const NOT_FOUND = -1;\n      return NOT_FOUND;\n    }\n\n    return validIndexes[Math.floor(Math.random() * validIndexes.length)];\n  }\n\n  /**\n   * @method getEmptyPositions - Get all empty positions from the map.\n   * @returns {Array<number>} - An array of indexes representing empty positions.\n   */\n  getEmptyPositions() {\n    const emptyPositions = [];\n    this.indexes.forEach((value, index) => {\n      if (value === null) {\n        emptyPositions.push(index);\n      }\n    });\n\n    return emptyPositions;\n  }\n\n  /**\n   * @method getOccupiedPositions - Get all occupied positions from the map.\n   * @returns {Array<number>} - An array of indexes representing occupied positions.\n   */\n  getOccupiedPositions() {\n    const emptyPositions = this.getEmptyPositions();\n    const emptySet = new Set(emptyPositions);\n    const occupiedPositions = [];\n    this.indexes.forEach((_, index) => {\n      if (!emptySet.has(index)) {\n        occupiedPositions.push(index);\n      }\n    });\n\n    return occupiedPositions;\n  }\n\n  /**\n   * @method getAdjacentPositions - Get all adjacent positions for a given position.\n   * @returns {Array<number>} - An array of indexes representing adjacent positions.\n   */\n  getAdjacentPositions() {\n    const occupiedPositions = this.getOccupiedPositions();\n\n    const adjacentPositions = new Set();\n    occupiedPositions.forEach((index) => {\n      const position = this.map.positions[index];\n      position.adjacents.forEach((adjacentIndex) => {\n        adjacentPositions.add(adjacentIndex);\n      });\n    });\n\n    return Array.from(adjacentPositions);\n  }\n\n  /**\n   * @method getAvailablePositions - Get all available positions from the map. (empty && adjacent)\n   * @returns {Array<number>} - An array of indexes representing available positions.\n   */\n  getAvailablePositions() {\n    const emptyPositions = this.getEmptyPositions();\n    const adjacentPositionsSet = new Set(this.getAdjacentPositions());\n\n    return emptyPositions.filter((index) => adjacentPositionsSet.has(index));\n  }\n\n  /**\n   * @method getHexagonPositions - Get positions that can form a hexagon.\n   * @param {Piece} piece - The piece to place at the specified position.\n   * @returns {Array<Array<number>>} - An array of positions (indexes) that can form a hexagon with how many hexagons can be formed.\n   * @throws {Error} - Throws an error if the piece is not an instance of Piece or if the index is out of bounds.\n   */\n  getHexagonPositions(piece) {\n    if (!(piece instanceof Piece)) {\n      throw new Error('Value must be an instance of Piece');\n    }\n\n    const availablePositions = this.getAvailablePositions();\n\n    const HEXAGON_FORMED_INDEX = 1;\n\n    return availablePositions\n      .map((index) => {\n        const hexagonsFormed = this.countHexagonsFormed(index, piece);\n        return [index, hexagonsFormed]; // Return index and how many hexagons can be formed\n      })\n      .filter((position) => position[HEXAGON_FORMED_INDEX] > 0) // Filter out positions that cannot form a hexagon\n      .sort((a, b) => {\n        return b[HEXAGON_FORMED_INDEX] - a[HEXAGON_FORMED_INDEX]; // Sort by the number of hexagons formed\n      }); // Sort by the number of hexagons formed\n  }\n\n  /**\n   * @method countHexagonsFormed - Count how many hexagons can be formed with a piece at the specified position.\n   * @param {number} index - The index of the position in the map. (0-based index)\n   * @param {Piece} piece - The piece to place at the specified position.\n   * @returns {number} - The number of hexagons that can be formed.\n   * @throws {Error} - Throws an error if the index is out of bounds or if the piece is not an instance of Piece.\n   */\n  countHexagonsFormed(index, piece) {\n    if (index < 0 || index >= this.map.positions.length) {\n      throw new Error('Index out of bounds');\n    }\n\n    if (!(piece instanceof Piece)) {\n      throw new Error('Value must be an instance of Piece');\n    }\n\n    this._isCountingHexagons = true; // Set a flag to indicate we are counting hexagons to avoid triggering events\n\n    const hexagonsFormed = this.place(index, piece);\n\n    this.back(1); // Undo the placement to avoid side effects\n\n    this._isCountingHexagons = false; // Reset the flag\n\n    return hexagonsFormed.length;\n  }\n\n  /**\n   * @method isEmpty - Check if the specified position is empty.\n   * @param {number} index - The index of the position in the map. (0-based index)\n   * @returns {boolean} - True if the position is empty, false otherwise.\n   * @throws {Error} - Throws an error if the index is out of bounds.\n   */\n  isEmpty(index) {\n    if (index < 0 || index >= this.map.positions.length) {\n      throw new Error('Index out of bounds');\n    }\n\n    return this.indexes[index] === null;\n  }\n\n  /**\n   * @method isCompleteHexagon - Check if the specified hexagon is complete (same color).\n   * @param {number} col - The column index.\n   * @param {number} row - The row index.\n   * @returns {boolean} - True if the hexagon is complete, false otherwise.\n   * @throws {Error} - Throws an error if the column or row is out of bounds.\n   */\n  isCompleteHexagon(col, row) {\n    if (col < 0 || col >= this.map.columns || row < 0 || row >= this.map.rows) {\n      throw new Error('Column or row out of bounds');\n    }\n\n    const hexagonColors = this.grid.getHexagon(col, row);\n\n    for (let i = 1; i < hexagonColors.length; i++) {\n      if (\n        hexagonColors[i] === null ||\n        hexagonColors[i - 1] === null ||\n        hexagonColors[i] !== hexagonColors[i - 1]\n      ) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * @method getCompleteHexagons - Get all complete hexagons on the board.\n   * @returns {Array<Object>} - An array of objects representing complete hexagons, each with coordinate and color.\n   */\n  getCompleteHexagons() {\n    return Array.from(this.hexagons).map((hexagon) => {\n      return {\n        coordinate: hexagon.split('-').map(Number),\n        color: this.hexagonColors.get(hexagon), // Get the color of the hexagon\n      };\n    });\n  }\n\n  /**\n   * @method addEventListener - Add an event listener for a specific event type.\n   * @param {string} eventType - The type of event to listen for (set, remove, form, destroy).\n   * @param {Function} listener - The listener function to be called when the event is triggered.\n   * @throws {Error} - Throws an error if the event type is invalid.\n   */\n  addEventListener(eventType, listener) {\n    if (!this.eventListeners[eventType]) {\n      throw new Error('Invalid event type');\n    }\n\n    this.eventListeners[eventType].add(listener);\n  }\n\n  /**\n   * @method removeEventListener - Remove an event listener for a specific event type.\n   * @param {string} eventType - The type of event to stop listening for (set, remove, form, destroy).\n   * @param {Function} listener - The listener function to remove.\n   * @throws {Error} - Throws an error if the event type is invalid.\n   */\n  removeEventListener(eventType, listener) {\n    if (!this.eventListeners[eventType]) {\n      throw new Error('Invalid event type');\n    }\n\n    this.eventListeners[eventType].delete(listener);\n  }\n\n  /**\n   * @method back - Undo the last move.\n   * @param {number} [steps=1] - The number of steps to undo.\n   * @returns {number} - The number of steps undone.\n   */\n  back(steps = 1) {\n    if (steps <= 0) {\n      return 0;\n    }\n\n    steps = Math.min(steps, this.history.length);\n\n    for (let i = 0; i < steps; i++) {\n      const lastAction = this.history.pop();\n      if (!lastAction) {\n        break;\n      }\n\n      if (lastAction.op === 'set') {\n        this.remove(lastAction.index);\n        this.history.pop(); // Remove the remove action from the history\n      } else if (lastAction.op === 'remove') {\n        this.set(lastAction.index, lastAction.value);\n      }\n    }\n    return steps;\n  }\n\n  /**\n   * @method clone - Create a deep copy of the board.\n   * @param {Object} [options={}] - Options for cloning the board.\n   * @param {boolean} [options.withListeners=false] - Whether to include event listeners in the cloned board.\n   * @param {boolean} [options.withHistory=false] - Whether to include history in the cloned board.\n   * @returns {Board} - A new instance of Board with the same properties.\n   */\n  clone(options = {}) {\n    const { withListeners = false, withHistory = false } = options;\n\n    const newBoard = deepClone(this);\n\n    if (!withListeners) {\n      newBoard.eventListeners = {\n        set: new Set(),\n        remove: new Set(),\n        form: new Set(),\n        destroy: new Set(),\n        clear: new Set(),\n      };\n    }\n\n    if (!withHistory) {\n      newBoard.history = [];\n    }\n\n    newBoard._isCountingHexagons = false; // Reset the flag in the cloned board\n\n    return newBoard;\n  }\n\n  /**\n   * @method clear - Clear the board and reset the history. (can't be undone)\n   */\n  clear() {\n    this.grid.clear();\n    this.indexes.fill(null);\n    this.hexagons.clear();\n    this.hexagonColors.clear(); // Clear the hexagon colors\n    this.history = [];\n\n    this._triggerEvent('clear'); // Trigger clear event\n  }\n\n  /**\n   * @method toJSON - Convert the board to a JSON representation.\n   * @param {Object} [options={}] - Options for converting the board to JSON.\n   * @param {boolean} [options.withHistory=false] - Whether to include history in the JSON representation.\n   * @returns {Object} - The JSON representation of the board.\n   */\n  toJSON(options = {}) {\n    const { withHistory = false } = options;\n\n    const newBoard = this.clone({\n      withListeners: false,\n      withHistory: withHistory,\n    });\n    const { map, grid, hexagons, hexagonColors } = newBoard;\n\n    const indexes = newBoard.indexes.map((piece) => {\n      if (piece) {\n        return piece.toJSON();\n      }\n      return null;\n    });\n\n    return {\n      map,\n      grid,\n      indexes,\n      hexagons: Array.from(hexagons),\n      hexagonColors: Array.from(hexagonColors.entries()),\n      history: withHistory\n        ? newBoard.history.map((action) => {\n            if (action.op === 'set') {\n              return action;\n            } else if (action.op === 'remove') {\n              return {\n                op: action.op,\n                index: action.index,\n                value: action.value.toJSON(),\n              };\n            }\n            return action; // Keep the action as is if it's not set or remove (no other actions defined yet)\n          })\n        : [],\n    };\n  }\n\n  /**\n   * @method fromJSON - Create a board from a JSON representation.\n   * @param {Object} json - The JSON representation of the board.\n   * @returns {Board} - A new instance of Board.\n   */\n  static fromJSON(json) {\n    const { map, grid, indexes, hexagons, hexagonColors, history } = json;\n\n    const newBoard = new Board(map);\n    newBoard.grid = grid;\n    newBoard.hexagons = new Set(hexagons);\n    newBoard.hexagonColors = new Map(hexagonColors);\n\n    newBoard.indexes = indexes.map((piece) => {\n      if (piece) {\n        return Piece.fromJSON(piece);\n      }\n      return null;\n    });\n\n    newBoard.history = history.map((action) => {\n      if (action.op === 'set') {\n        return action;\n      } else if (action.op === 'remove') {\n        return {\n          op: action.op,\n          index: action.index,\n          value: Piece.fromJSON(action.value),\n        };\n      }\n      return action; // Keep the action as is if it's not set or remove (no other actions defined yet)\n    });\n\n    return newBoard;\n  }\n}\n\nmodule.exports = Board;\n\n\n//# sourceURL=webpack://Tridecco/./src/board.js?");

/***/ }),

/***/ "./src/hexGrid.js":
/*!************************!*\
  !*** ./src/hexGrid.js ***!
  \************************/
/***/ ((module) => {

eval("/**\n * @fileoverview Hexagonal Grid (Offset Coordinates)\n * @description This file contains the implementation of a hexagonal grid using offset coordinates.\n */\n\n/**\n * @class HexGrid - A class representing a hexagonal grid.\n */\nclass HexGrid {\n  /**\n   * @constructor\n   * @param {number} columns - The number of columns in the grid.\n   * @param {number} rows - The number of rows in the grid.\n   * @param {string} type - The type of the grid ('odd-r' or 'even-r' or 'odd-q' or 'even-q').\n   * @throws {Error} - Throws an error if the type is invalid.\n   */\n  constructor(columns, rows, type) {\n    if (!['odd-r', 'even-r', 'odd-q', 'even-q'].includes(type)) {\n      throw new Error('Invalid grid type');\n    }\n    this.type = type;\n\n    this.grid = new Array(rows);\n    for (let r = 0; r < rows; r++) {\n      this.grid[r] = new Array(columns).fill(null);\n    }\n  }\n\n  /**\n   * @property {Object} OFFSET - The offsets for the hex grid.\n   */\n  static OFFSET = {\n    NEGATIVE_ONE: -1,\n    ZERO: 0,\n    ONE: 1,\n  };\n\n  /**\n   * @property {Object} DIRECTION_OFFSETS - The offsets for each direction in the hex grid.\n   */\n  static DIRECTION_OFFSETS = {\n    UP_LEFT: [HexGrid.OFFSET.NEGATIVE_ONE, HexGrid.OFFSET.NEGATIVE_ONE],\n    UP: [HexGrid.OFFSET.ZERO, HexGrid.OFFSET.NEGATIVE_ONE],\n    UP_RIGHT: [HexGrid.OFFSET.ONE, HexGrid.OFFSET.NEGATIVE_ONE],\n    RIGHT: [HexGrid.OFFSET.ONE, HexGrid.OFFSET.ZERO],\n    DOWN_RIGHT: [HexGrid.OFFSET.ONE, HexGrid.OFFSET.ONE],\n    DOWN: [HexGrid.OFFSET.ZERO, HexGrid.OFFSET.ONE],\n    DOWN_LEFT: [HexGrid.OFFSET.NEGATIVE_ONE, HexGrid.OFFSET.ONE],\n    LEFT: [HexGrid.OFFSET.NEGATIVE_ONE, HexGrid.OFFSET.ZERO],\n  };\n\n  /**\n   * @property {Object} DIRECTIONS - The directions for adjacent hexes based on the grid type.\n   */\n  static DIRECTIONS = {\n    'odd-r': [\n      [\n        HexGrid.DIRECTION_OFFSETS.UP_LEFT,\n        HexGrid.DIRECTION_OFFSETS.UP,\n        HexGrid.DIRECTION_OFFSETS.RIGHT,\n        HexGrid.DIRECTION_OFFSETS.DOWN,\n        HexGrid.DIRECTION_OFFSETS.DOWN_LEFT,\n        HexGrid.DIRECTION_OFFSETS.LEFT,\n      ], // Even rows\n      [\n        HexGrid.DIRECTION_OFFSETS.UP,\n        HexGrid.DIRECTION_OFFSETS.UP_RIGHT,\n        HexGrid.DIRECTION_OFFSETS.RIGHT,\n        HexGrid.DIRECTION_OFFSETS.DOWN_RIGHT,\n        HexGrid.DIRECTION_OFFSETS.DOWN,\n        HexGrid.DIRECTION_OFFSETS.LEFT,\n      ], // Odd rows\n    ],\n    'even-r': [\n      [\n        HexGrid.DIRECTION_OFFSETS.UP,\n        HexGrid.DIRECTION_OFFSETS.UP_RIGHT,\n        HexGrid.DIRECTION_OFFSETS.RIGHT,\n        HexGrid.DIRECTION_OFFSETS.DOWN_RIGHT,\n        HexGrid.DIRECTION_OFFSETS.DOWN,\n        HexGrid.DIRECTION_OFFSETS.LEFT,\n      ], // Even rows\n      [\n        HexGrid.DIRECTION_OFFSETS.UP_LEFT,\n        HexGrid.DIRECTION_OFFSETS.UP,\n        HexGrid.DIRECTION_OFFSETS.RIGHT,\n        HexGrid.DIRECTION_OFFSETS.DOWN,\n        HexGrid.DIRECTION_OFFSETS.DOWN_LEFT,\n        HexGrid.DIRECTION_OFFSETS.LEFT,\n      ], // Odd rows\n    ],\n    'odd-q': [\n      [\n        HexGrid.DIRECTION_OFFSETS.UP,\n        HexGrid.DIRECTION_OFFSETS.UP_RIGHT,\n        HexGrid.DIRECTION_OFFSETS.RIGHT,\n        HexGrid.DIRECTION_OFFSETS.DOWN,\n        HexGrid.DIRECTION_OFFSETS.LEFT,\n        HexGrid.DIRECTION_OFFSETS.UP_LEFT,\n      ], // Even columns\n      [\n        HexGrid.DIRECTION_OFFSETS.UP,\n        HexGrid.DIRECTION_OFFSETS.RIGHT,\n        HexGrid.DIRECTION_OFFSETS.DOWN_RIGHT,\n        HexGrid.DIRECTION_OFFSETS.DOWN,\n        HexGrid.DIRECTION_OFFSETS.DOWN_LEFT,\n        HexGrid.DIRECTION_OFFSETS.LEFT,\n      ], // Odd columns\n    ],\n    'even-q': [\n      [\n        HexGrid.DIRECTION_OFFSETS.UP,\n        HexGrid.DIRECTION_OFFSETS.RIGHT,\n        HexGrid.DIRECTION_OFFSETS.DOWN_RIGHT,\n        HexGrid.DIRECTION_OFFSETS.DOWN,\n        HexGrid.DIRECTION_OFFSETS.DOWN_LEFT,\n        HexGrid.DIRECTION_OFFSETS.LEFT,\n      ], // Even columns\n      [\n        HexGrid.DIRECTION_OFFSETS.UP,\n        HexGrid.DIRECTION_OFFSETS.UP_RIGHT,\n        HexGrid.DIRECTION_OFFSETS.RIGHT,\n        HexGrid.DIRECTION_OFFSETS.DOWN,\n        HexGrid.DIRECTION_OFFSETS.LEFT,\n        HexGrid.DIRECTION_OFFSETS.UP_LEFT,\n      ], // Odd columns\n    ],\n  };\n\n  /**\n   * @method get - Get the value at the specified column and row.\n   * @param {number} col - The column index.\n   * @param {number} row - The row index.\n   * @returns {*} - The value at the specified position.\n   */\n  get(col, row) {\n    if (\n      row < 0 ||\n      row >= this.grid.length ||\n      col < 0 ||\n      col >= this.grid[row].length\n    ) {\n      return null;\n    }\n    return this.grid[row][col];\n  }\n\n  /**\n   * @method set - Set the value at the specified column and row.\n   * @param {number} col - The column index.\n   * @param {number} row - The row index.\n   * @param {*} value - The value to set.\n   */\n  set(col, row, value) {\n    if (\n      row < 0 ||\n      row >= this.grid.length ||\n      col < 0 ||\n      col >= this.grid[row].length\n    ) {\n      return;\n    }\n    this.grid[row][col] = value;\n  }\n\n  /**\n   * @method remove - Remove the value at the specified column and row.\n   * @param {number} col - The column index.\n   * @param {number} row - The row index.\n   * @returns {*} - The removed value.\n   */\n  remove(col, row) {\n    if (\n      row < 0 ||\n      row >= this.grid.length ||\n      col < 0 ||\n      col >= this.grid[row].length\n    ) {\n      return null;\n    }\n    const value = this.grid[row][col];\n    this.grid[row][col] = null;\n    return value;\n  }\n\n  /**\n   * @method getAdjacents - Get the adjacent hexes for a given column and row.\n   * @param {number} col - The column index.\n   * @param {number} row - The row index.\n   * @returns {Array} - An array of adjacent hexes.\n   * @throws {Error} - Throws an error if the grid type is invalid.\n   */\n  getAdjacents(col, row) {\n    const directions = HexGrid.DIRECTIONS[this.type];\n    if (!directions) {\n      throw new Error('Invalid grid type');\n    }\n\n    const adjacents = [];\n    const TWO = 2;\n    const isOdd = (this.type.includes('r') ? row : col) % TWO !== 0;\n    const dirSet = isOdd ? directions[1] : directions[0];\n\n    for (const [dCol, dRow] of dirSet) {\n      const newCol = col + dCol;\n      const newRow = row + dRow;\n      const value = this.get(newCol, newRow);\n      if (value !== null) {\n        adjacents.push({ col: newCol, row: newRow, value: value });\n      }\n    }\n\n    return adjacents;\n  }\n\n  /**\n   * @method forEach - Iterate over each hex in the grid.\n   * @param {Function} callback - The function to call for each hex.\n   */\n  forEach(callback) {\n    for (let r = 0; r < this.grid.length; r++) {\n      for (let c = 0; c < this.grid[r].length; c++) {\n        callback(this.get(c, r), c, r);\n      }\n    }\n  }\n\n  /**\n   * @method clone - Create a deep copy of the grid.\n   * @returns {HexGrid} - A new HexGrid instance with the same values.\n   */\n  clone() {\n    const newGrid = new HexGrid(\n      this.grid[0].length,\n      this.grid.length,\n      this.type,\n    );\n\n    for (let r = 0; r < this.grid.length; r++) {\n      for (let c = 0; c < this.grid[r].length; c++) {\n        newGrid.set(c, r, this.get(c, r));\n      }\n    }\n\n    return newGrid;\n  }\n\n  /**\n   * @method clear - Clear the grid.\n   */\n  clear() {\n    for (let r = 0; r < this.grid.length; r++) {\n      for (let c = 0; c < this.grid[r].length; c++) {\n        this.grid[r][c] = null;\n      }\n    }\n  }\n}\n\nmodule.exports = HexGrid;\n\n\n//# sourceURL=webpack://Tridecco/./src/hexGrid.js?");

/***/ }),

/***/ "./src/index.js":
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Entry Point\n * @description This file serves as the entry point for the library.\n */\n\nmodule.exports = {\n  HexGrid: __webpack_require__(/*! ./hexGrid */ \"./src/hexGrid.js\"),\n  TriHexGrid: __webpack_require__(/*! ./triHexGrid */ \"./src/triHexGrid.js\"),\n  Board: __webpack_require__(/*! ./board */ \"./src/board.js\"),\n  Piece: __webpack_require__(/*! ./piece */ \"./src/piece.js\"),\n  maps: {\n    board: {\n      default: __webpack_require__(/*! ../maps/board/default */ \"./maps/board/default.js\"),\n    },\n    renderer: {\n      default: __webpack_require__(/*! ../maps/renderer/default */ \"./maps/renderer/default.js\"),\n    },\n  },\n  TexturePack: __webpack_require__(/*! ./texturePack */ \"./src/texturePack.js\"),\n  Renderer: __webpack_require__(/*! ./renderer */ \"./src/renderer.js\"),\n};\n\n\n//# sourceURL=webpack://Tridecco/./src/index.js?");

/***/ }),

/***/ "./src/piece.js":
/*!**********************!*\
  !*** ./src/piece.js ***!
  \**********************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Game Piece\n * @description This file contains the implementation of a Tridecco game piece.\n */\n\nconst deepClone = __webpack_require__(/*! ./utils/deepClone */ \"./src/utils/deepClone.js\");\n\n/**\n * @class Piece - A class representing the game piece.\n */\nclass Piece {\n  /**\n   * @constructor\n   * @param {Array<string>} colors - The colors of the piece.\n   * @param {Object} [params={}] - Optional parameters for the piece.\n   * @throws {Error} - If colors is not an array of 2 strings or if params is not an object.\n   */\n  constructor(colors, params = {}) {\n    const PIECE_COLOR_COUNT = 2;\n\n    if (!Array.isArray(colors)) {\n      throw new Error('colors must be an array of strings');\n    }\n    if (colors.length !== PIECE_COLOR_COUNT) {\n      throw new Error(\n        'colors must be an array of 2 strings representing the colors of the piece',\n      );\n    }\n    if (colors.some((color) => typeof color !== 'string')) {\n      throw new Error('colors must be an array of strings');\n    }\n\n    if (params && (typeof params !== 'object' || Array.isArray(params))) {\n      throw new Error('params must be an object and not an array');\n    }\n\n    Object.assign(this, params);\n    this.colors = colors;\n    this.colorsKey = colors.join('-');\n  }\n\n  /**\n   * @method equals - Check if two pieces are equal. (compares colors)\n   * @param {Piece} other - The other piece to compare with.\n   * @returns {boolean} - True if the pieces are equal, false otherwise.\n   */\n  equals(other) {\n    if (!(other instanceof Piece)) {\n      return false;\n    }\n\n    return this.colorsKey === other.colorsKey;\n  }\n\n  /**\n   * @method clone - Create a deep copy of the piece.\n   * @returns {Piece} - A new instance of Piece with the same properties.\n   */\n  clone() {\n    return deepClone(this);\n  }\n\n  /**\n   * @method toJSON - Convert the piece to a JSON representation.\n   * @returns {Object} - The JSON representation of the piece.\n   */\n  toJSON() {\n    const newPiece = this.clone();\n    const { colors, colorsKey, ...customProperties } = newPiece;\n    return { colors, customProperties };\n  }\n\n  /**\n   * @method fromJSON - Create a piece from a JSON representation.\n   * @param {Object} json - The JSON representation of the piece.\n   * @returns {Piece} - A new instance of Piece.\n   */\n  static fromJSON(json) {\n    const { colors, customProperties } = json;\n    return new Piece(colors, customProperties);\n  }\n}\n\nmodule.exports = Piece;\n\n\n//# sourceURL=webpack://Tridecco/./src/piece.js?");

/***/ }),

/***/ "./src/renderer.js":
/*!*************************!*\
  !*** ./src/renderer.js ***!
  \*************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Game Renderer\n * @description This file contains the implementation of a game board renderer for the Tridecco game.\n */\n\nconst DEFAULT_ASSETS_URL =\n  'https://cdn.jsdelivr.net/gh/tridecco/game-board@0.4.2/assets/';\n\nconst Board = __webpack_require__(/*! ./board */ \"./src/board.js\");\nconst TexturePack = __webpack_require__(/*! ./texturePack */ \"./src/texturePack.js\");\n\nconst defaultMap = __webpack_require__(/*! ../maps/renderer/default */ \"./maps/renderer/default.js\");\n\nconst HALF = 2;\nconst TWO = 2;\nconst HALF_PI_DEGREES = 180;\nconst ALPHA_CHANNEL_INDEX = 3;\nconst NOT_FOUND = -1;\nconst MAX_PIECE_ID_RGB = 0xffffff;\nconst MAX_COLOR_COMPONENT = 0xff;\nconst BITS_PER_BYTE = 8;\nconst BITS_PER_TWO_BYTES = 16;\nconst COLOR_GAP_FACTOR = 10;\n\n/**\n * @class Renderer - A class representing the game board renderer.\n */\nclass Renderer {\n  /**\n   * @constructor\n   * @param {Object} options - The options for the renderer.\n   * @param {Board} options.board - The game board to be rendered.\n   * @param {HTMLElement} options.container - The DOM element to be used for rendering the board.\n   * @param {Object} options.map - The map to be used for rendering the board.\n   * @param {string} options.texturesUrl - The URL of the texture pack.\n   * @param {string} options.backgroundUrl - The URL of the background image.\n   * @param {string} options.gridUrl - The URL of the grid image.\n   * @param {Function} callback - A callback function to be executed after loading the textures, background, and grid.\n   * @throws {Error} - If board is not an instance of Board, if canvas is not an HTMLElement, or if map is not a valid map object, or if texturesUrl, backgroundUrl, or gridUrl are not strings, or if the callback is not a function, or if the environment is not a browser.\n   */\n  constructor(\n    {\n      board,\n      container,\n      map = defaultMap,\n      texturesUrl = DEFAULT_ASSETS_URL + 'textures/classic/normal',\n      backgroundUrl = DEFAULT_ASSETS_URL + 'backgrounds/wooden-board.jpg',\n      gridUrl = DEFAULT_ASSETS_URL + 'grids/black.png',\n    },\n    callback = () => {},\n  ) {\n    if (!(board instanceof Board)) {\n      throw new Error('board must be an instance of Board');\n    }\n    if (!(container instanceof HTMLElement)) {\n      throw new Error('canvas must be an instance of HTMLElement');\n    }\n    if (\n      !map ||\n      !map.height ||\n      !map.width ||\n      !map.tiles ||\n      !map.tiles.length ||\n      !map.hexagons\n    ) {\n      throw new Error('map must be a valid map object');\n    }\n    if (typeof texturesUrl !== 'string') {\n      throw new Error(\n        'texturesUrl must be a string representing the URL of the texture pack',\n      );\n    }\n    if (typeof backgroundUrl !== 'string') {\n      throw new Error('backgroundUrl must be a string');\n    }\n    if (typeof gridUrl !== 'string') {\n      throw new Error('gridUrl must be a string');\n    }\n    if (typeof callback !== 'function') {\n      throw new Error('callback must be a function');\n    }\n    if (typeof window === 'undefined') {\n      throw new Error('Renderer can only be used in a browser environment');\n    }\n\n    this.board = board;\n    this.map = map;\n\n    this.container = container;\n    this.container.style.position = 'relative';\n    this.canvas = document.createElement('canvas');\n    this.context = this.canvas.getContext('2d');\n\n    this.width = null;\n    this.height = null;\n    this.ratio = this.map.width / this.map.height; // Ratio of the map width to the map height\n    this.widthRatio = null; // Ratio of the canvas width to the map width\n    this.heightRatio = null; // Ratio of the canvas height to the map height\n    this.devicePixelRatio = window.devicePixelRatio || 1; // Device pixel ratio for high-DPI displays\n\n    this.offScreenCanvases = {\n      background: new OffscreenCanvas(1, 1), // Background Image + Grid Image\n      pieces: new OffscreenCanvas(1, 1), // Pieces + Hexagons\n      piecesPreview: new OffscreenCanvas(1, 1), // Preview of pieces\n      mask: new OffscreenCanvas(1, 1), // Mask for displaying avilable positions\n      hitmap: new OffscreenCanvas(1, 1), // Hitmap for detecting pieces\n      temp: new OffscreenCanvas(1, 1), // Temporary canvas for rendering\n    };\n    this.offScreenContexts = {\n      background: this.offScreenCanvases.background.getContext('2d'),\n      pieces: this.offScreenCanvases.pieces.getContext('2d'),\n      piecesPreview: this.offScreenCanvases.piecesPreview.getContext('2d'),\n      mask: this.offScreenCanvases.mask.getContext('2d'),\n      hitmap: this.offScreenCanvases.hitmap.getContext('2d', {\n        willReadFrequently: true,\n        initialImageSmoothingEnabled: false,\n        imageSmoothingEnabled: false,\n      }),\n      temp: this.offScreenCanvases.temp.getContext('2d', {\n        willReadFrequently: true,\n        initialImageSmoothingEnabled: false,\n        imageSmoothingEnabled: false,\n      }),\n    };\n\n    this.background = null;\n    this.grid = null;\n    this.textures = null;\n\n    this.requestedFrames = new Set(); // Store requested frames to avoid duplicate rendering\n\n    this.resizeObserverInitialized = false;\n    this.resizeObserver = new ResizeObserver(() => {\n      if (!this.resizeObserverInitialized) {\n        this.resizeObserverInitialized = true;\n        return; // Skip the first call to avoid unnecessary rendering\n      }\n      if (this.requestedFrames.has('resize')) {\n        return; // Skip if a frame is already requested\n      }\n\n      this.requestedFrames.add('resize');\n      requestAnimationFrame(() => {\n        this._setUpCanvas();\n        this.requestedFrames.delete('resize');\n      });\n\n      this._triggerEvent('resize', {\n        canvas: {\n          width: this.canvas.width,\n          height: this.canvas.height,\n        },\n        container: {\n          width: this.container.clientWidth,\n          height: this.container.clientHeight,\n        },\n      });\n    });\n    this.resizeObserver.observe(this.container);\n\n    this.eventListeners = {\n      dragover: new Set(), // Listeners for dragover events\n      dragoverAvailable: new Set(), // Listeners for dragover events with available positions\n      drop: new Set(), // Listeners for drop events\n      dropAvailable: new Set(), // Listeners for drop events with available positions\n      mousemove: new Set(), // Listeners for hover events\n      mousemoveAvailable: new Set(), // Listeners for hover events with available positions\n      click: new Set(), // Listeners for click events\n      clickAvailable: new Set(), // Listeners for click events with available positions\n      resize: new Set(), // Listeners for resize events\n    };\n    this._initEventListeners(); // Initialize event listeners\n    this.eventHandlers = new Map();\n\n    this.mutationObserver = new MutationObserver((mutationsList, observer) => {\n      for (const mutation of mutationsList) {\n        if (mutation.removedNodes) {\n          mutation.removedNodes.forEach((removedNode) => {\n            if (removedNode === this.canvas || removedNode === this.container) {\n              this.destroy();\n            }\n          });\n        }\n      }\n    });\n    this.mutationObserver.observe(this.container.parentNode || this.container, {\n      childList: true,\n      subtree: true,\n    });\n\n    this._isPreviewing = false; // Flag to check if a piece is being previewed\n    this._isShowingAvailablePositions = false; // Flag to check if available positions are being shown\n    this._showingAvailablePositions = new Array(); // Store currently shown available positions\n    this._previewingPositions = new Map(); // Store currently shown previewing positions\n\n    this._setUpBoard();\n    this._loadAssets(texturesUrl, backgroundUrl, gridUrl).then(() => {\n      this._setUpCanvas();\n      callback(this); // Call the callback function after loading assets and setting up the canvas\n    });\n\n    this.isDestroyed = false; // Flag to check if the renderer is destroyed\n  }\n\n  /**\n   * @method _initEventListeners - Initializes event listeners for the canvas.\n   */\n  _initEventListeners() {\n    this.canvas.addEventListener('dragover', (event) => {\n      const dpr = this.devicePixelRatio;\n      const coords = {\n        x: event.offsetX * dpr,\n        y: event.offsetY * dpr,\n      };\n      event.preventDefault(); // Prevent default behavior to allow dropping\n      this._triggerEvent(\n        'dragover',\n        this._getPieceFromCoordinate(coords.x, coords.y),\n      );\n\n      const availablePiece = this._getPieceFromCoordinate(\n        coords.x,\n        coords.y,\n        true,\n      ); // Only consider available pieces\n      if (availablePiece !== NOT_FOUND) {\n        this._triggerEvent('dragoverAvailable', availablePiece);\n      }\n    });\n\n    this.canvas.addEventListener('drop', (event) => {\n      const dpr = this.devicePixelRatio;\n      const coords = {\n        x: event.offsetX * dpr,\n        y: event.offsetY * dpr,\n      };\n      event.preventDefault(); // Prevent default behavior to allow dropping\n      this._triggerEvent(\n        'drop',\n        this._getPieceFromCoordinate(coords.x, coords.y),\n      );\n\n      const availablePiece = this._getPieceFromCoordinate(\n        coords.x,\n        coords.y,\n        true,\n      ); // Only consider available pieces\n      if (availablePiece !== NOT_FOUND) {\n        this._triggerEvent('dropAvailable', availablePiece);\n      }\n    });\n\n    this.canvas.addEventListener('click', (event) => {\n      const dpr = this.devicePixelRatio;\n      const coords = {\n        x: event.offsetX * dpr,\n        y: event.offsetY * dpr,\n      };\n      this._triggerEvent(\n        'click',\n        this._getPieceFromCoordinate(coords.x, coords.y),\n      );\n\n      const availablePiece = this._getPieceFromCoordinate(\n        coords.x,\n        coords.y,\n        true,\n      ); // Only consider available pieces\n      if (availablePiece !== NOT_FOUND) {\n        this._triggerEvent('clickAvailable', availablePiece);\n      }\n    });\n\n    this.canvas.addEventListener('mousemove', (event) => {\n      const dpr = this.devicePixelRatio;\n      const coords = {\n        x: event.offsetX * dpr,\n        y: event.offsetY * dpr,\n      };\n      this._triggerEvent(\n        'mousemove',\n        this._getPieceFromCoordinate(coords.x, coords.y),\n      );\n\n      const availablePiece = this._getPieceFromCoordinate(\n        coords.x,\n        coords.y,\n        true,\n      ); // Only consider available pieces\n      if (availablePiece !== NOT_FOUND) {\n        this._triggerEvent('mousemoveAvailable', availablePiece);\n      }\n    });\n  }\n\n  /**\n   * @method _triggerEvent - Trigger an event for a specific action.\n   * @param {string} eventType - The type of event to trigger (dragover, dragoverAvailable, drop, dropAvailable, mousemove, mousemoveAvailable, click, clickAvailable, resize).\n   * @param {...*} args - The arguments to pass to the event listeners.\n   */\n  _triggerEvent(eventType, ...args) {\n    if (this.eventListeners[eventType]) {\n      this.eventListeners[eventType].forEach((listener) => {\n        listener(...args);\n      });\n    }\n  }\n\n  /**\n   * @method _setUpBoard - Sets up the board event listeners for rendering.\n   */\n  _setUpBoard() {\n    const renderPiece = function renderPiece(index, piece) {\n      this._renderPiece(index, piece.colorsKey, this.map.tiles[index].flipped);\n      this._render();\n    }.bind(this);\n\n    const renderPiecesAndHexagons = function renderPiecesAndHexagons() {\n      this._renderPiecesAndHexagons();\n      this._render();\n    }.bind(this);\n\n    const renderHexagons = function renderHexagons(hexagons) {\n      for (const hexagon of hexagons) {\n        this._renderHexagon(hexagon.coordinate, hexagon.color);\n      }\n      this._render();\n    }.bind(this);\n\n    const clearBoard = function clearBoard() {\n      this._clearBoard();\n      this._render();\n    }.bind(this);\n\n    this.board.addEventListener('set', renderPiece);\n    this.board.addEventListener('remove', renderPiecesAndHexagons);\n    this.board.addEventListener('form', renderHexagons);\n    this.board.addEventListener('destroy', renderPiecesAndHexagons);\n    this.board.addEventListener('clear', clearBoard);\n\n    this.eventHandlers.set('set', renderPiece);\n    this.eventHandlers.set('remove', renderPiecesAndHexagons);\n    this.eventHandlers.set('form', renderHexagons);\n    this.eventHandlers.set('destroy', renderPiecesAndHexagons);\n    this.eventHandlers.set('clear', clearBoard);\n  }\n\n  /**\n   * @method _loadAssets - Loads textures, background, and grid images.\n   * @param {string} texturesUrl - The URL of the texture pack.\n   * @param {string} backgroundUrl - The URL of the background image.\n   * @param {string} gridUrl - The URL of the grid image.\n   * @returns {Promise<void[]>} - A promise that resolves when all assets are loaded.\n   */\n  async _loadAssets(texturesUrl, backgroundUrl, gridUrl) {\n    const loadingAssetsPromises = [\n      new Promise((resolve) => {\n        this.textures = new TexturePack(texturesUrl, resolve);\n      }),\n      new Promise((resolve) => {\n        this.background = new Image();\n        this.background.src = backgroundUrl;\n        this.background.onload = resolve;\n      }),\n      new Promise((resolve) => {\n        this.grid = new Image();\n        this.grid.src = gridUrl;\n        this.grid.onload = resolve;\n      }),\n    ];\n\n    return Promise.all(loadingAssetsPromises);\n  }\n\n  /**\n   * @method _setUpCanvas - Sets up the canvas dimensions and renders initial elements, applying device pixel ratio (DPR) for high-DPI displays.\n   */\n  _setUpCanvas() {\n    const containerWidth = this.container.clientWidth;\n    const containerHeight = this.container.clientHeight;\n    const mapRatio = this.ratio;\n    let canvasWidth, canvasHeight;\n\n    if (containerWidth / containerHeight > mapRatio) {\n      canvasHeight = containerHeight;\n      canvasWidth = canvasHeight * mapRatio;\n    } else {\n      canvasWidth = containerWidth;\n      canvasHeight = canvasWidth / mapRatio;\n    }\n\n    const dpr = this.devicePixelRatio;\n    this.canvas.width = canvasWidth * dpr;\n    this.canvas.height = canvasHeight * dpr;\n    this.canvas.style.width = `${canvasWidth}px`;\n    this.canvas.style.height = `${canvasHeight}px`;\n\n    const leftOffset = (containerWidth - canvasWidth) / HALF;\n    const topOffset = (containerHeight - canvasHeight) / HALF;\n    this.canvas.style.position = 'absolute';\n    this.canvas.style.left = `${leftOffset}px`;\n    this.canvas.style.top = `${topOffset}px`;\n\n    if (!this.canvas.parentNode) {\n      this.container.appendChild(this.canvas);\n    }\n\n    for (const key in this.offScreenCanvases) {\n      this.offScreenCanvases[key].width = canvasWidth * dpr;\n      this.offScreenCanvases[key].height = canvasHeight * dpr;\n    }\n\n    this.context.scale(dpr, dpr);\n    for (const key in this.offScreenContexts) {\n      this.offScreenContexts[key].scale(dpr, dpr);\n    }\n\n    this.width = canvasWidth;\n    this.height = canvasHeight;\n    this.widthRatio = canvasWidth / this.map.width;\n    this.heightRatio = canvasHeight / this.map.height;\n\n    this._clearAllCanvases();\n    this._renderBackgroundAndGrid();\n    if (this.board.indexes.length) {\n      this._renderPiecesAndHexagons();\n    }\n    if (this._isShowingAvailablePositions) {\n      this.showAvailablePositions(this._showingAvailablePositions);\n    }\n    if (this._isPreviewing) {\n      this._previewingPositions.forEach((piece, index) => {\n        this.previewPiece(index, piece);\n      });\n    }\n    this._setUpHitmap();\n    this._render();\n  }\n\n  /**\n   * @method _render - Renders the main canvas by drawing layers from off-screen canvases.\n   */\n  _render() {\n    if (this.requestedFrames.has('render')) {\n      return;\n    }\n\n    requestAnimationFrame(() => {\n      this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n      this.context.drawImage(\n        this.offScreenCanvases.background,\n        0,\n        0,\n        this.width,\n        this.height,\n      );\n      this.context.drawImage(\n        this.offScreenCanvases.pieces,\n        0,\n        0,\n        this.width,\n        this.height,\n      );\n      this.context.drawImage(\n        this.offScreenCanvases.piecesPreview,\n        0,\n        0,\n        this.width,\n        this.height,\n      );\n      this.context.drawImage(\n        this.offScreenCanvases.mask,\n        0,\n        0,\n        this.width,\n        this.height,\n      );\n\n      this.requestedFrames.delete('render');\n    });\n\n    this.requestedFrames.add('render');\n  }\n\n  /**\n   * @method _renderBackgroundAndGrid - Renders the background and grid images onto the background off-screen canvas.\n   */\n  _renderBackgroundAndGrid() {\n    // Clear the background canvas\n    const backgroundContext = this.offScreenContexts.background;\n    backgroundContext.clearRect(\n      0,\n      0,\n      this.offScreenCanvases.background.width,\n      this.offScreenCanvases.background.height,\n    );\n\n    // Draw the background image (centered and fully covering the canvas)\n    const bgWidth = this.background.width;\n    const bgHeight = this.background.height;\n    const bgRatio = bgWidth / bgHeight;\n\n    let bgDrawWidth, bgDrawHeight, bgOffsetX, bgOffsetY;\n\n    if (this.width / this.height > bgRatio) {\n      // Canvas is wider than the background image ratio\n      bgDrawWidth = this.width;\n      bgDrawHeight = this.width / bgRatio;\n      bgOffsetX = 0;\n      bgOffsetY = (this.height - bgDrawHeight) / HALF;\n    } else {\n      // Canvas is taller than the background image ratio\n      bgDrawHeight = this.height;\n      bgDrawWidth = this.height * bgRatio;\n      bgOffsetX = (this.width - bgDrawWidth) / HALF;\n      bgOffsetY = 0;\n    }\n\n    backgroundContext.drawImage(\n      this.background,\n      bgOffsetX,\n      bgOffsetY,\n      bgDrawWidth,\n      bgDrawHeight,\n    );\n\n    // Draw the grid image (centered and filling as much as possible without overflow)\n    const gridWidth = this.grid.width;\n    const gridHeight = this.grid.height;\n    const gridRatio = gridWidth / gridHeight;\n\n    let gridDrawWidth, gridDrawHeight, gridOffsetX, gridOffsetY;\n\n    if (this.width / this.height > gridRatio) {\n      // Canvas is wider than the grid image ratio\n      gridDrawHeight = this.height;\n      gridDrawWidth = this.height * gridRatio;\n      gridOffsetX = (this.width - gridDrawWidth) / HALF;\n      gridOffsetY = 0;\n    } else {\n      // Canvas is taller than the grid image ratio\n      gridDrawWidth = this.width;\n      gridDrawHeight = this.width / gridRatio;\n      gridOffsetX = 0;\n      gridOffsetY = (this.height - gridDrawHeight) / HALF;\n    }\n\n    backgroundContext.drawImage(\n      this.grid,\n      gridOffsetX,\n      gridOffsetY,\n      gridDrawWidth,\n      gridDrawHeight,\n    );\n  }\n\n  /**\n   * @method _renderPiecesAndHexagons - Clears and re-renders all pieces and hexagons on the pieces off-screen canvas.\n   */\n  _renderPiecesAndHexagons() {\n    this._clearBoard();\n    this._renderPieces();\n    this._renderHexagons();\n  }\n\n  /**\n   * @method _renderPieces - Renders all pieces from the board's indexes onto the pieces off-screen canvas.\n   */\n  _renderPieces() {\n    const pieces = this.board.indexes;\n    for (let i = 0; i < pieces.length; i++) {\n      const piece = pieces[i];\n      if (piece) {\n        const flipped = this.map.tiles[i].flipped;\n        this._renderPiece(i, piece.colorsKey, flipped);\n      }\n    }\n  }\n\n  /**\n   * @method _renderPiece - Renders a single game piece onto a specified canvas context.\n   * @param {number} index - The index of the piece to render, corresponding to its position in the board's index array.\n   * @param {string} colorsKey - The color key of the piece, used to retrieve the correct texture.\n   * @param {boolean} flipped - A boolean indicating if the piece should be rendered flipped.\n   * @param {CanvasRenderingContext2D} targetContext - The 2D rendering context of the canvas to draw onto.\n   * @param {string} [fillColor] - Optional fill color to override texture colors, used for hitmap rendering.\n   * @throws {Error} - If the index is out of bounds or if the texture for the piece is not found.\n   */\n  _renderPiece(\n    index,\n    colorsKey,\n    flipped,\n    targetContext = this.offScreenContexts.pieces,\n    fillColor,\n  ) {\n    const tile = this.map.tiles[index];\n    if (!tile) {\n      throw new Error(`Tile index ${index} out of bounds`);\n    }\n\n    const textureKey = flipped ? `${colorsKey}-flipped` : colorsKey;\n    const texture = this.textures.get('tiles', textureKey);\n    if (!texture) {\n      throw new Error(`Texture key \"${textureKey}\" not found in textures`);\n    }\n\n    const x = tile.x * this.widthRatio;\n    const y = tile.y * this.heightRatio;\n    const imageWidth = texture.width;\n    const imageHeight = texture.height;\n\n    let width, height;\n    if (tile.width !== undefined && tile.width !== null) {\n      width = tile.width * this.widthRatio;\n      height =\n        tile.height !== undefined && tile.height !== null\n          ? tile.height * this.heightRatio\n          : (width * imageHeight) / imageWidth;\n    } else if (tile.height !== undefined && tile.height !== null) {\n      height = tile.height * this.heightRatio;\n      width = (height * imageWidth) / imageHeight;\n    } else {\n      width = imageWidth * (this.widthRatio || 1);\n      height = imageHeight * (this.heightRatio || 1);\n    }\n\n    if (!(width > 0 && height > 0)) {\n      return;\n    }\n\n    const rotation = tile.rotation || 0;\n    const angle = (rotation * Math.PI) / HALF_PI_DEGREES;\n\n    targetContext.save();\n    targetContext.translate(x + width / HALF, y + height / HALF);\n    targetContext.rotate(angle);\n\n    if (fillColor) {\n      const tempCanvas = this.offScreenCanvases.temp;\n      const tempCtx = this.offScreenContexts.temp;\n\n      tempCanvas.width = Math.max(1, Math.ceil(width));\n      tempCanvas.height = Math.max(1, Math.ceil(height));\n\n      tempCtx.drawImage(texture, 0, 0, tempCanvas.width, tempCanvas.height);\n\n      tempCtx.globalCompositeOperation = 'source-in';\n      tempCtx.fillStyle = fillColor;\n      tempCtx.fillRect(0, 0, tempCanvas.width, tempCanvas.height);\n\n      tempCtx.globalCompositeOperation = 'source-over';\n\n      targetContext.drawImage(\n        tempCanvas,\n        -width / HALF,\n        -height / HALF,\n        width,\n        height,\n      );\n    } else {\n      targetContext.drawImage(\n        texture,\n        -width / HALF,\n        -height / HALF,\n        width,\n        height,\n      );\n    }\n\n    targetContext.restore();\n  }\n\n  /**\n   * @method _renderHexagons - Renders complete hexagons on the pieces off-screen canvas.\n   */\n  _renderHexagons() {\n    const hexagons = this.board.getCompleteHexagons();\n    for (const hexagon of hexagons) {\n      this._renderHexagon(hexagon.coordinate, hexagon.color);\n    }\n  }\n\n  /**\n   * @method _renderHexagon - Renders a single hexagon onto the pieces off-screen canvas.\n   * @param {Array<number>} coordinate - The column and row coordinate of the hexagon to render.\n   * @param {string} color - The color key of the hexagon texture to use for rendering.\n   */\n  _renderHexagon(coordinate, color) {\n    const hexagon = this.map.hexagons[`${coordinate[0]}-${coordinate[1]}`];\n    const texture = this.textures.get('hexagons', color);\n    const x = hexagon.x * this.widthRatio;\n    const y = hexagon.y * this.heightRatio;\n    const imageWidth = texture.width;\n    const imageHeight = texture.height;\n\n    const width = hexagon.width\n      ? hexagon.width * this.widthRatio\n      : (hexagon.height * this.heightRatio * imageWidth) / imageHeight;\n    const height = hexagon.height\n      ? hexagon.height * this.heightRatio\n      : (hexagon.width * this.widthRatio * imageHeight) / imageWidth;\n\n    this.offScreenContexts.pieces.drawImage(texture, x, y, width, height);\n  }\n\n  /**\n   * @method _clearAllCanvases - Clears all off-screen canvases and the main display canvas.\n   */\n  _clearAllCanvases() {\n    this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    for (const key in this.offScreenCanvases) {\n      this.offScreenContexts[key].clearRect(\n        0,\n        0,\n        this.offScreenCanvases[key].width,\n        this.offScreenCanvases[key].height,\n      );\n    }\n  }\n\n  /**\n   * @method _clearBoard - Clears the pieces off-screen canvas, effectively removing all pieces and hexagons rendering.\n   */\n  _clearBoard() {\n    this.offScreenContexts.pieces.clearRect(\n      0,\n      0,\n      this.offScreenCanvases.pieces.width,\n      this.offScreenCanvases.pieces.height,\n    );\n  }\n\n  /**\n   * @method _setUpHitmap - Sets up the hitmap by rendering each piece with a unique color ID onto the hitmap off-screen canvas.\n   */\n  _setUpHitmap() {\n    this.offScreenContexts.hitmap.clearRect(\n      0,\n      0,\n      this.offScreenCanvases.hitmap.width,\n      this.offScreenCanvases.hitmap.height,\n    );\n\n    const pieceIndices = this.board.map.positions.map((_, index) => index);\n\n    for (const index of pieceIndices) {\n      const gappedPieceId = index * COLOR_GAP_FACTOR + 1;\n\n      if (gappedPieceId > MAX_PIECE_ID_RGB) {\n        console.warn(\n          `Gapped ID ${gappedPieceId} for index ${index} exceeds limit.`,\n        );\n        continue;\n      }\n\n      const r = gappedPieceId & MAX_COLOR_COMPONENT;\n      const g = (gappedPieceId >> BITS_PER_BYTE) & MAX_COLOR_COMPONENT;\n      const b = (gappedPieceId >> BITS_PER_TWO_BYTES) & MAX_COLOR_COMPONENT;\n      const hitColor = `rgb(${r}, ${g}, ${b})`;\n\n      this._renderPiece(\n        index,\n        'empty',\n        this.map.tiles[index].flipped,\n        this.offScreenContexts.hitmap,\n        hitColor,\n      );\n    }\n  }\n\n  /**\n   * @method _getPieceFromCoordinate - Retrieves the index of a piece at a given canvas coordinate using the hitmap.\n   * @param {number} x - The x coordinate on the canvas.\n   * @param {number} y - The y coordinate on the canvas.\n   * @param {boolean} [onlyAvailable=false] - Optional flag to only consider available positions.\n   * @returns {number} - The index of the piece at the coordinate, or -1 if no piece is found.\n   */\n  _getPieceFromCoordinate(x, y, onlyAvailable = false) {\n    const imageData = this.offScreenContexts.hitmap.getImageData(x, y, 1, 1);\n    const pixelData = imageData.data;\n    const r = pixelData[0];\n    const g = pixelData[1];\n    const b = pixelData[TWO];\n    const alpha = pixelData[ALPHA_CHANNEL_INDEX];\n\n    if (alpha === 0) {\n      return NOT_FOUND;\n    }\n\n    const decodedGappedId =\n      r | (g << BITS_PER_BYTE) | (b << BITS_PER_TWO_BYTES);\n\n    if (decodedGappedId === 0) {\n      return NOT_FOUND;\n    }\n\n    if ((decodedGappedId - 1) % COLOR_GAP_FACTOR !== 0) {\n      return NOT_FOUND;\n    }\n\n    const pieceIndex = (decodedGappedId - 1) / COLOR_GAP_FACTOR;\n    if (!(pieceIndex >= 0 && pieceIndex < this.board.map.positions.length)) {\n      return NOT_FOUND;\n    }\n\n    if (onlyAvailable) {\n      const availablePositions = new Set(this.board.getAvailablePositions());\n      if (!availablePositions.has(pieceIndex)) {\n        return NOT_FOUND;\n      }\n    }\n\n    return pieceIndex;\n  }\n\n  /**\n   * @method previewPiece - Renders a preview of a piece at a given index with a semi-transparent overlay.\n   * @param {number} index - The index of the board position where the piece preview is to be rendered.\n   * @param {Piece} piece - The Piece object to be previewed.\n   * @param {string} [fillColor='rgba(255, 255, 255, 0.5)'] - Optional fill color for the preview overlay, default is semi-transparent white.\n   * @throws {Error} - If the piece is invalid or if the index is out of bounds.\n   */\n  previewPiece(index, piece, fillColor = 'rgba(255, 255, 255, 0.5)') {\n    if (!piece || !piece.colorsKey) {\n      throw new Error('Invalid piece object for preview');\n    }\n\n    const tile = this.map.tiles[index];\n    if (!tile) {\n      throw new Error('Tile index out of bounds for preview');\n    }\n\n    this._renderPiece(\n      index,\n      piece.colorsKey,\n      tile.flipped,\n      this.offScreenContexts.piecesPreview,\n    );\n    this._renderPiece(\n      index,\n      piece.colorsKey,\n      tile.flipped,\n      this.offScreenContexts.piecesPreview,\n      fillColor,\n    );\n\n    this._render();\n    this._isPreviewing = true;\n    this._previewingPositions.set(index, piece);\n  }\n\n  /**\n   * @method clearPreview - Clears any piece previews currently rendered on the piecesPreview off-screen canvas.\n   */\n  clearPreview() {\n    this.offScreenContexts.piecesPreview.clearRect(\n      0,\n      0,\n      this.offScreenCanvases.piecesPreview.width,\n      this.offScreenCanvases.piecesPreview.height,\n    );\n    this._render();\n    this._isPreviewing = false;\n    this._previewingPositions.clear();\n  }\n\n  /**\n   * @method showAvailablePositions - Highlights available positions on the board using a mask on the mask off-screen canvas.\n   * @param {Array<number>} [positions=this.board.getAvailablePositions()] - An array of position indexes to highlight as available.\n   * @param {string} [fillColor='rgba(0, 0, 0, 0.5)'] - Optional fill color for the highlight mask, default is semi-transparent black.\n   * @throws {Error} - If positions is not an array.\n   */\n  showAvailablePositions(\n    positions = this.board.getAvailablePositions(),\n    fillColor = 'rgba(0, 0, 0, 0.5)',\n  ) {\n    if (!Array.isArray(positions)) {\n      throw new Error(\n        'positions must be an array of available position indexes',\n      );\n    }\n\n    if (this._isShowingAvailablePositions) {\n      this.clearAvailablePositions(); // Clear existing highlights before showing new ones\n    }\n\n    const maskContext = this.offScreenContexts.mask;\n\n    // Fill the entire canvas with a semi-transparent black overlay\n    maskContext.fillStyle = fillColor;\n    maskContext.fillRect(\n      0,\n      0,\n      this.offScreenCanvases.mask.width,\n      this.offScreenCanvases.mask.height,\n    );\n\n    // Use the empty texture as a stencil to \"cut out\" the available positions\n    for (const index of positions) {\n      const tile = this.map.tiles[index];\n      if (!tile) {\n        continue;\n      }\n\n      const texture = this.textures.get(\n        'tiles',\n        `${this.map.tiles[index].flipped ? 'empty-flipped' : 'empty'}`,\n      );\n\n      const x = tile.x * this.widthRatio;\n      const y = tile.y * this.heightRatio;\n      const imageWidth = texture.width;\n      const imageHeight = texture.height;\n\n      let width, height;\n      if (tile.width !== undefined && tile.width !== null) {\n        width = tile.width * this.widthRatio;\n        height =\n          tile.height !== undefined && tile.height !== null\n            ? tile.height * this.heightRatio\n            : (width * imageHeight) / imageWidth;\n      } else if (tile.height !== undefined && tile.height !== null) {\n        height = tile.height * this.heightRatio;\n        width = (height * imageWidth) / imageHeight;\n      } else {\n        width = imageWidth * (this.widthRatio || 1);\n        height = imageHeight * (this.heightRatio || 1);\n      }\n\n      // Ensure width and height are valid numbers > 0\n      if (!(width > 0 && height > 0)) {\n        continue;\n      }\n\n      const rotation = tile.rotation || 0;\n      const angle = (rotation * Math.PI) / HALF_PI_DEGREES; // Convert degrees to radians\n\n      maskContext.save();\n      maskContext.translate(x + width / HALF, y + height / HALF);\n      maskContext.rotate(angle);\n\n      // Use the empty texture to clear the overlay at the available position\n      maskContext.globalCompositeOperation = 'destination-out';\n      maskContext.drawImage(\n        texture,\n        -width / HALF,\n        -height / HALF,\n        width,\n        height,\n      );\n\n      maskContext.restore();\n    }\n\n    // Render the mask canvas to the main canvas\n    this._render();\n\n    this._isShowingAvailablePositions = true; // Set the flag to indicate available positions are being shown\n    this._showingAvailablePositions = positions; // Store the currently shown available positions\n  }\n\n  /**\n   * @method clearAvailablePositions - Clears the highlight mask from the mask off-screen canvas, removing highlights of available positions.\n   */\n  clearAvailablePositions() {\n    this.offScreenContexts.mask.clearRect(\n      0,\n      0,\n      this.offScreenCanvases.mask.width,\n      this.offScreenCanvases.mask.height,\n    );\n    this._render();\n\n    this._isShowingAvailablePositions = false; // Reset the flag\n    this._showingAvailablePositions = []; // Clear the stored available positions\n  }\n\n  /**\n   * @method getTexture - Retrieves a texture from the loaded texture pack by type and key.\n   * @param {string} type - The texture type (e.g., 'tiles', 'hexagons').\n   * @param {string} key - The key of the texture image within the texture type.\n   * @returns {HTMLImageElement} - The requested texture image element.\n   * @throws {Error} - If textures have not been loaded yet, indicating assets are not ready.\n   */\n  getTexture(type, key) {\n    if (!this.textures) {\n      throw new Error('Textures not loaded yet');\n    }\n    return this.textures.get(type, key);\n  }\n\n  /**\n   * @method updateBoard - Updates the board instance used by the renderer, re-initializing the canvas and re-rendering the board.\n   * @param {Board} newBoard - The new board instance to replace the current board.\n   * @throws {Error} - If newBoard is not a valid board instance.\n   */\n  updateBoard(newBoard) {\n    if (!(newBoard instanceof Board)) {\n      throw new Error('newBoard must be a valid board instance');\n    }\n\n    // Remove event listeners from the board\n    this.board.removeEventListener('set', this.eventHandlers.get('set'));\n    this.board.removeEventListener('remove', this.eventHandlers.get('remove'));\n    this.board.removeEventListener('form', this.eventHandlers.get('form'));\n    this.board.removeEventListener(\n      'destroy',\n      this.eventHandlers.get('destroy'),\n    );\n    this.board.removeEventListener('clear', this.eventHandlers.get('clear'));\n    this.eventHandlers.clear(); // Clear old event listeners\n\n    this.board = newBoard; // Update the board instance\n\n    // Re-setup the board listeners to ensure they are using the new board\n    this._setUpBoard(); // Re-setup the board event listeners\n\n    // Clear the board and re-render everything\n    this._setUpCanvas(); // Re-setup canvas to apply new board dimensions\n  }\n\n  /**\n   * @method updateMap - Updates the game board map, re-initializes the canvas, and re-renders the board.\n   * @param {Object} newMap - The new map configuration object to replace the current map.\n   * @throws {Error} - If newMap is not a valid map object, validation checks for required map properties.\n   */\n  updateMap(newMap) {\n    if (\n      !newMap ||\n      !newMap.height ||\n      !newMap.width ||\n      !newMap.tiles ||\n      !newMap.tiles.length ||\n      !newMap.hexagons\n    ) {\n      throw new Error('newMap must be a valid map object');\n    }\n\n    this.map = newMap;\n\n    // Recalculate the ratio based on the new map dimensions\n    this.ratio = this.map.width / this.map.height;\n\n    // Re-setup the board listeners to ensure they are using the new map\n    this.board.removeEventListener('set', this.eventHandlers.get('set'));\n    this.board.removeEventListener('remove', this.eventHandlers.get('remove'));\n    this.board.removeEventListener('form', this.eventHandlers.get('form'));\n    this.board.removeEventListener(\n      'destroy',\n      this.eventHandlers.get('destroy'),\n    );\n    this.board.removeEventListener('clear', this.eventHandlers.get('clear'));\n    this.eventHandlers.clear(); // Clear old event listeners\n    this._setUpBoard(); // Re-setup the board event listeners\n\n    // Clear the board and re-render everything\n    this._setUpCanvas(); // Re-setup canvas to apply new map dimensions\n  }\n\n  /**\n   * @method updateTextures - Updates the texture pack used by the renderer, loading new textures from a given URL.\n   * @param {string} texturesUrl - The URL from which to load the new texture pack.\n   * @returns {Promise<void>} - A promise that resolves when the new texture pack is loaded, pieces and hitmap are re-rendered.\n   * @throws {Error} - If texturesUrl is not a string or if loading the texture pack fails.\n   */\n  async updateTextures(texturesUrl) {\n    if (typeof texturesUrl !== 'string') {\n      throw new Error(\n        'texturesUrl must be a string representing the URL of the texture pack',\n      );\n    }\n\n    return new Promise((resolve, reject) => {\n      this.textures = new TexturePack(\n        texturesUrl,\n        () => {\n          this._renderPiecesAndHexagons(); // Re-render pieces and hexagons with new textures\n          this._render(); // Re-render the main canvas to show the new textures\n          this._setUpHitmap(); // Re-render the hitmap with new textures\n\n          if (this._isPreviewing) {\n            const previewingPositions = [...this._previewingPositions];\n            this.clearPreview(); // Clear existing previews\n            previewingPositions.forEach(([index, piece]) => {\n              this.previewPiece(index, piece); // Re-render previews with new textures\n            });\n          }\n\n          resolve();\n        },\n        (error) => {\n          console.error('Error loading new texture pack:', error);\n          reject(new Error('Failed to load new texture pack'));\n        },\n      );\n    });\n  }\n\n  /**\n   * @method updateBackground - Updates the background image of the renderer with a new image from the provided URL.\n   * @param {string} backgroundUrl - The URL of the new background image to load.\n   * @returns {Promise<void>} - A promise that resolves when the new background image is loaded and the canvas is re-rendered.\n   * @throws {Error} - If backgroundUrl is not a string or if loading the background image fails.\n   */\n  async updateBackground(backgroundUrl) {\n    if (typeof backgroundUrl !== 'string') {\n      throw new Error('backgroundUrl must be a string');\n    }\n\n    return new Promise((resolve, reject) => {\n      const newBackground = new Image();\n      newBackground.src = backgroundUrl;\n      newBackground.onload = () => {\n        this.background = newBackground;\n        this._renderBackgroundAndGrid(); // Re-render the background and grid\n        this._render(); // Re-render the main canvas to show the new background\n        resolve();\n      };\n      newBackground.onerror = (error) => {\n        console.error('Error loading new background image:', error);\n        reject(new Error('Failed to load new background image'));\n      };\n    });\n  }\n\n  /**\n   * @method updateGrid - Updates the grid image of the renderer with a new image from the provided URL.\n   * @param {string} gridUrl - The URL of the new grid image to load.\n   * @returns {Promise<void>} - A promise that resolves when the new grid image is loaded and the canvas is re-rendered.\n   * @throws {Error} - If gridUrl is not a string or if loading the grid image fails.\n   */\n  async updateGrid(gridUrl) {\n    if (typeof gridUrl !== 'string') {\n      throw new Error('gridUrl must be a string');\n    }\n\n    return new Promise((resolve, reject) => {\n      const newGrid = new Image();\n      newGrid.src = gridUrl;\n      newGrid.onload = () => {\n        this.grid = newGrid;\n        this._renderBackgroundAndGrid(); // Re-render the background and grid\n        this._render(); // Re-render the main canvas to show the new grid\n        resolve();\n      };\n      newGrid.onerror = (error) => {\n        console.error('Error loading new grid image:', error);\n        reject(new Error('Failed to load new grid image'));\n      };\n    });\n  }\n\n  /**\n   * @method addEventListener - Adds a listener for specific renderer events, enabling custom actions on events like piece placement.\n   * @param {string} eventType - The event type to listen for (dragover, drop, mousemove, click, resize).\n   * @param {Function} listener - The function to execute when the event is triggered; receives event-specific arguments.\n   * @param {Object} [options] - Optional parameters, including `onlyAvailable: true` to filter events to available positions only.\n   * @throws {Error} - If eventType is not a valid event type.\n   */\n  addEventListener(eventType, listener, options = {}) {\n    if (!this.eventListeners[eventType] || eventType.endsWith('Available')) {\n      throw new Error('Invalid event type');\n    }\n\n    if (eventType !== 'resize' && options.onlyAvailable) {\n      this.eventListeners[`${eventType}Available`].add(listener);\n    } else {\n      this.eventListeners[eventType].add(listener);\n    }\n  }\n\n  /**\n   * @method removeEventListener - Removes a previously added event listener for a given event type, preventing further execution on that event.\n   * @param {string} eventType - The event type from which to remove the listener.\n   * @param {Function} listener - The listener function to be removed.\n   * @throws {Error} - If eventType is not a valid event type, indicating an attempt to remove listener from a non-existent event.\n   */\n  removeEventListener(eventType, listener) {\n    if (!this.eventListeners[eventType] || eventType.endsWith('Available')) {\n      throw new Error('Invalid event type');\n    }\n\n    this.eventListeners[eventType].delete(listener);\n    if (eventType !== 'resize') {\n      this.eventListeners[`${eventType}Available`].delete(listener);\n    }\n  }\n\n  /**\n   * @method destroy - Tears down the renderer, releasing resources, removing listeners, and detaching the canvas from the DOM.\n   */\n  destroy() {\n    if (this.isDestroyed) {\n      return; // Prevent double destruction\n    }\n\n    // Remove event listeners from the board\n    this.board.removeEventListener('set', this.eventHandlers.get('set'));\n    this.board.removeEventListener('remove', this.eventHandlers.get('remove'));\n    this.board.removeEventListener('form', this.eventHandlers.get('form'));\n    this.board.removeEventListener(\n      'destroy',\n      this.eventHandlers.get('destroy'),\n    );\n    this.board.removeEventListener('clear', this.eventHandlers.get('clear'));\n\n    // Clear event handlers map\n    this.eventHandlers.clear();\n\n    // Remove all event listeners from the renderer\n    for (const eventType in this.eventListeners) {\n      this.eventListeners[eventType].clear();\n    }\n\n    // Clear all canvases\n    this._clearAllCanvases();\n\n    // Stop observing the container resize\n    if (this.resizeObserver) {\n      this.resizeObserver.disconnect();\n    }\n\n    // Stop observing mutation events\n    if (this.mutationObserver) {\n      this.mutationObserver.disconnect();\n    }\n\n    // Remove the canvas from the container\n    if (this.canvas.parentNode) {\n      this.container.removeChild(this.canvas);\n    }\n\n    // Nullify references to free up memory\n    this.canvas = null;\n    this.context = null;\n    for (const key in this.offScreenCanvases) {\n      this.offScreenCanvases[key] = null;\n      this.offScreenContexts[key] = null;\n    }\n    this.offScreenCanvases = null;\n    this.offScreenContexts = null;\n\n    this.board = null;\n    this.map = null;\n    this.container = null;\n    this.background = null;\n    this.grid = null;\n    this.textures = null;\n\n    this.resizeObserverInitialized = false;\n    this.requestedFrames.clear();\n    this.requestedFrames = null;\n\n    this.eventListeners = null;\n\n    this._isPreviewing = false;\n    this._isShowingAvailablePositions = false;\n    this._showingAvailablePositions = null;\n\n    this._previewingPositions.clear();\n    this._previewingPositions = null;\n\n    this.isDestroyed = true; // Mark the renderer as destroyed\n  }\n}\n\nmodule.exports = Renderer;\n\n\n//# sourceURL=webpack://Tridecco/./src/renderer.js?");

/***/ }),

/***/ "./src/texturePack.js":
/*!****************************!*\
  !*** ./src/texturePack.js ***!
  \****************************/
/***/ ((module) => {

eval("/**\n * @fileoverview Texture Pack\n * @description This file contains the implementation of a texture pack for the Tridecco game rendering.\n */\n\n/**\n * @class TexturePack - A class representing a texture pack for the Tridecco game board.\n */\nclass TexturePack {\n  /**\n   * @constructor\n   * @param {string} texturesUrl - The URL of the texture pack.\n   * @param {Function} callback - A callback function to be executed after loading the textures.\n   * @throws {Error} - If textures is not an string or if the callback is not a function or if the environment is not a browser.\n   */\n  constructor(texturesUrl, callback = () => {}) {\n    if (typeof texturesUrl !== 'string') {\n      throw new Error(\n        'texturesUrl must be a string representing the URL of the texture pack',\n      );\n    }\n    if (typeof callback !== 'function') {\n      throw new Error('callback must be a function');\n    }\n    if (typeof window === 'undefined') {\n      throw new Error('TexturePack can only be used in a browser environment');\n    }\n\n    this.textures = {\n      tiles: new Map(),\n      hexagons: new Map(),\n    };\n\n    this.loadTextures(texturesUrl, callback);\n  }\n\n  /**\n   * @method loadTextures - Loads textures from the provided paths and stores them in the textures map.\n   * @param {string} texturesUrl - The URL of the texture pack.\n   * @param {Function} callback - The callback to execute after loading textures.\n   */\n  loadTextures(texturesUrl, callback) {\n    fetch(`${texturesUrl}/index.json`)\n      .then((response) => {\n        if (!response.ok) {\n          throw new Error(`Failed to fetch texture index from ${texturesUrl}`);\n        }\n        return response.json(); // Parse the JSON response\n      })\n      .then((textures) => {\n        const tiles = textures.tiles || {};\n        const hexagons = textures.hexagons || {};\n\n        const loadTilePromises = Object.entries(tiles).map(([key, path]) => {\n          return new Promise((resolve, reject) => {\n            const img = new Image();\n            img.crossOrigin = 'anonymous'; // Set crossorigin attribute\n            img.src = `${texturesUrl}/${path}`;\n            img.onload = () => {\n              this.textures.tiles.set(key, img); // Store tile texture\n              resolve();\n            };\n            img.onerror = () => {\n              reject(new Error(`Failed to load tile texture: ${path}`));\n            };\n          });\n        });\n\n        const loadHexPromises = Object.entries(hexagons).map(([key, path]) => {\n          return new Promise((resolve, reject) => {\n            const img = new Image();\n            img.crossOrigin = 'anonymous'; // Set crossorigin attribute\n            img.src = `${texturesUrl}/${path}`;\n            img.onload = () => {\n              this.textures.hexagons.set(key, img); // Store hexagon texture\n              resolve();\n            };\n            img.onerror = () => {\n              reject(new Error(`Failed to load hexagon texture: ${path}`));\n            };\n          });\n        });\n\n        // Wait for all tile and hexagon textures to load\n        Promise.all([...loadTilePromises, ...loadHexPromises])\n          .then(() => {\n            // All textures loaded successfully\n            callback(this); // Execute the callback with the loaded TexturePack instance\n          })\n          .catch((error) => {\n            // Handle any error that occurred during loading\n            console.error('Error loading textures:', error);\n            callback(null, error); // Pass null to callback in case of error\n          });\n      })\n      .catch((error) => {\n        // Handle fetch error\n        console.error('Error fetching texture index:', error);\n        callback(null, error); // Pass null to callback in case of fetch error\n      });\n  }\n\n  /**\n   * @method get - Retrieve a texture by its type and key.\n   * @param {string} type - The type of texture to retrieve ('tiles' or 'hexagons').\n   * @param {string} key - The key of the texture to retrieve.\n   * @returns {HTMLImageElement|null} - The texture image if found, otherwise null.\n   */\n  get(type, key) {\n    // Retrieve a texture by its key\n    if (type === 'tiles') {\n      // Return tile texture\n      return this.textures.tiles.get(key) || null;\n    } else if (type === 'hexagons') {\n      // Return hexagon texture\n      return this.textures.hexagons.get(key) || null;\n    } else {\n      // Invalid type\n      console.error(`Invalid texture type: ${type}`);\n      return null;\n    }\n  }\n}\n\nmodule.exports = TexturePack;\n\n\n//# sourceURL=webpack://Tridecco/./src/texturePack.js?");

/***/ }),

/***/ "./src/triHexGrid.js":
/*!***************************!*\
  !*** ./src/triHexGrid.js ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @fileoverview Triangular Hexagonal Grid (Based on HexGrid)\n * @description This file contains the implementation of a triangular hexagonal grid based on the HexGrid class.\n */\n\nconst HexGrid = __webpack_require__(/*! ./hexGrid */ \"./src/hexGrid.js\");\n\nconst TRIANGLE_COUNT = 6; // Number of triangles in a hexagon\n\n/**\n * @class TriHexGrid - A class representing a triangular hexagonal grid.\n */\nclass TriHexGrid extends HexGrid {\n  /**\n   * @constructor\n   * @param {number} columns - The number of columns in the grid.\n   * @param {number} rows - The number of rows in the grid.\n   * @param {string} type - The type of the grid ('odd-r' or 'even-r' or 'odd-q' or 'even-q').\n   */\n  constructor(columns, rows, type) {\n    super(columns, rows, type);\n  }\n\n  /**\n   * @method get - Get the value at the specified column, row, and triangle.\n   * @param {number} col - The column index.\n   * @param {number} row - The row index.\n   * @param {number} triangle - The triangle index (1-6).\n   * @returns {*} - The value at the specified position and triangle.\n   * @throws {Error} - Throws an error if the triangle index is out of range.\n   */\n  get(col, row, triangle) {\n    if (triangle < 1 || triangle > TRIANGLE_COUNT) {\n      throw new Error('Triangle index must be between 1 and 6');\n    }\n\n    const hex = super.get(col, row);\n    return hex ? hex.triangles[String(triangle)] || null : null;\n  }\n\n  /**\n   * @method set - Set the value at the specified column, row, and triangles.\n   * @param {Array<Array<number>>} positions - The positions to set the value, each position is [col, row, triangle].\n   * @param {*} value - The value to set.\n   * @throws {Error} - Throws an error if the triangle index is out of range.\n   */\n  set(positions, value) {\n    positions.forEach(([col, row, triangle]) => {\n      if (triangle < 1 || triangle > TRIANGLE_COUNT) {\n        throw new Error('Triangle index must be between 1 and 6');\n      }\n\n      const hex = super.get(col, row) || { triangles: {} };\n      hex.triangles[String(triangle)] = value;\n      super.set(col, row, hex);\n    });\n  }\n\n  /**\n   * @method remove - Remove the value at the specified column, row, and triangles.\n   * @param {Array<Array<number>>} positions - The positions to remove the value, each position is [col, row, triangle].\n   * @returns {Array<*>} - The removed values.\n   * @throws {Error} - Throws an error if the triangle index is out of range.\n   */\n  remove(positions) {\n    return positions.map(([col, row, triangle]) => {\n      if (triangle < 1 || triangle > TRIANGLE_COUNT) {\n        throw new Error('Triangle index must be between 1 and 6');\n      }\n\n      const hex = super.get(col, row);\n      if (!hex) {\n        return null;\n      }\n\n      const value = hex.triangles[String(triangle)] || null;\n      delete hex.triangles[String(triangle)];\n      if (Object.keys(hex.triangles).length === 0) {\n        super.set(col, row, null);\n      } else {\n        super.set(col, row, hex);\n      }\n      return value;\n    });\n  }\n\n  /**\n   * @method getHexagon - Get all the values of the hexagon at the specified column and row.\n   * @param {number} col - The column index.\n   * @param {number} row - The row index.\n   * @returns {Array<*>} - The values of the hexagon.\n   */\n  getHexagon(col, row) {\n    const hex = super.get(col, row);\n    if (!hex) {\n      return Array(TRIANGLE_COUNT).fill(null);\n    }\n\n    return Array.from(\n      { length: TRIANGLE_COUNT },\n      (_, i) => hex.triangles[String(i + 1)] || null,\n    );\n  }\n\n  /**\n   * @method setHexagon - Set the values of the hexagon at the specified column and row.\n   * @param {number} col - The column index.\n   * @param {number} row - The row index.\n   * @param {Array<*>} values - The values of the hexagon.\n   */\n  setHexagon(col, row, values) {\n    const hex = super.get(col, row) || { triangles: {} };\n    values.forEach((value, i) => {\n      hex.triangles[String(i + 1)] = value;\n    });\n    super.set(col, row, hex);\n  }\n\n  /**\n   * @method removeHexagon - Remove all the values of the hexagon at the specified column and row.\n   * @param {number} col - The column index.\n   * @param {number} row - The row index.\n   * @returns {Array<*>} - The removed values.\n   */\n  removeHexagon(col, row) {\n    const hex = super.get(col, row);\n    if (!hex) {\n      return Array(TRIANGLE_COUNT).fill(null);\n    }\n\n    const values = Array.from(\n      { length: TRIANGLE_COUNT },\n      (_, i) => hex.triangles[String(i + 1)] || null,\n    );\n    super.set(col, row, null);\n    return values;\n  }\n\n  /**\n   * @method isFull - Check if all the triangles of the hexagon at the specified column and row are filled.\n   * @param {number} col - The column index.\n   * @param {number} row - The row index.\n   * @returns {boolean} - True if all the triangles are filled, false otherwise.\n   */\n  isFull(col, row) {\n    const hex = super.get(col, row);\n    return hex ? Object.keys(hex.triangles).length === TRIANGLE_COUNT : false;\n  }\n\n  /**\n   * @method clone - Create a deep copy of the grid.\n   * @returns {TriHexGrid} - A new instance of TriHexGrid with the same values as the current grid.\n   */\n  clone() {\n    const newGrid = new TriHexGrid(this.columns, this.rows, this.type);\n\n    newGrid.grid = this.grid.map((row) => {\n      return row.map((hex) => {\n        if (!hex) {\n          return null;\n        }\n\n        const newHex = { triangles: {} };\n        Object.keys(hex.triangles).forEach((triangle) => {\n          newHex.triangles[triangle] = hex.triangles[triangle];\n        });\n\n        return newHex;\n      });\n    });\n\n    return newGrid;\n  }\n}\n\nmodule.exports = TriHexGrid;\n\n\n//# sourceURL=webpack://Tridecco/./src/triHexGrid.js?");

/***/ }),

/***/ "./src/utils/deepClone.js":
/*!********************************!*\
  !*** ./src/utils/deepClone.js ***!
  \********************************/
/***/ ((module) => {

eval("/**\n * @fileoverview Deep Clone Utility\n * @description This file contains a utility function for deep cloning objects.\n */\n\n/**\n * @function deepClone - Deep clone an object.\n * @param {*} obj - The value to clone.\n * @param {WeakMap<object, object>} [memo=new WeakMap()] - Internal parameter to handle circular references.\n * @returns {*} - A deep copy of the input value.\n */\nfunction deepClone(obj, memo = new WeakMap()) {\n  if (obj === null) {\n    return obj;\n  }\n\n  if (typeof obj !== 'object') {\n    return obj;\n  }\n\n  if (memo.has(obj)) {\n    return memo.get(obj);\n  }\n\n  const Constructor = obj.constructor;\n\n  switch (Constructor) {\n    case Date:\n      return new Constructor(obj);\n    case RegExp:\n      return new Constructor(obj);\n    case Map:\n      const newMap = new Constructor();\n      memo.set(obj, newMap);\n      for (const [key, value] of obj) {\n        newMap.set(deepClone(key, memo), deepClone(value, memo));\n      }\n      return newMap;\n    case Set:\n      const newSet = new Constructor();\n      memo.set(obj, newSet);\n      for (const value of obj) {\n        newSet.add(deepClone(value, memo));\n      }\n      return newSet;\n    case Array:\n      const newArray = new Constructor(obj.length);\n      memo.set(obj, newArray);\n      for (let i = 0; i < obj.length; i++) {\n        newArray[i] = deepClone(obj[i], memo);\n      }\n      return newArray;\n    case Object:\n      const proto = Object.getPrototypeOf(obj);\n      const newObj = Object.create(proto);\n      memo.set(obj, newObj);\n      for (const key of Reflect.ownKeys(obj)) {\n        const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n        if (descriptor) {\n          if (descriptor.get || descriptor.set) {\n            Object.defineProperty(newObj, key, {\n              get: descriptor.get\n                ? () => deepClone(descriptor.get.call(obj), memo)\n                : undefined,\n              set: descriptor.set\n                ? (v) => descriptor.set.call(newObj, deepClone(v, memo))\n                : undefined,\n              enumerable: descriptor.enumerable,\n              configurable: descriptor.configurable,\n            });\n          } else {\n            newObj[key] = deepClone(descriptor.value, memo);\n          }\n        }\n      }\n      return newObj;\n    case Function:\n      return obj;\n    case Symbol:\n      return obj;\n    case WeakMap:\n      return new Constructor(); // Cannot deep clone WeakMap contents\n    case WeakSet:\n      return new Constructor(); // Cannot deep clone WeakSet contents\n    case Promise:\n      return new Constructor((resolve, reject) => {\n        obj.then(\n          (val) => resolve(deepClone(val, memo)),\n          (reason) => reject(deepClone(reason, memo)),\n        );\n      });\n    default:\n      if (typeof obj[Symbol.iterator] === 'function') {\n        const iterable = obj[Symbol.iterator]();\n        let result = iterable.next();\n        const items = [];\n        while (!result.done) {\n          items.push(deepClone(result.value, memo));\n          result = iterable.next();\n        }\n        return new Constructor(...items);\n      }\n      const defaultProto = Object.getPrototypeOf(obj);\n      const customObj =\n        defaultProto === null\n          ? Object.create(null)\n          : Object.create(defaultProto);\n      memo.set(obj, customObj);\n      for (const key of Reflect.ownKeys(obj)) {\n        const descriptor = Object.getOwnPropertyDescriptor(obj, key);\n        if (descriptor) {\n          if (descriptor.get || descriptor.set) {\n            Object.defineProperty(customObj, key, {\n              get: descriptor.get\n                ? () => deepClone(descriptor.get.call(obj), memo)\n                : undefined,\n              set: descriptor.set\n                ? (v) => descriptor.set.call(customObj, deepClone(v, memo))\n                : undefined,\n              enumerable: descriptor.enumerable,\n              configurable: descriptor.configurable,\n            });\n          } else {\n            customObj[key] = deepClone(descriptor.value, memo);\n          }\n        }\n      }\n      return customObj;\n  }\n}\n\nmodule.exports = deepClone;\n\n\n//# sourceURL=webpack://Tridecco/./src/utils/deepClone.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/index.js");
/******/ 	
/******/ 	return __webpack_exports__;
/******/ })()
;
});