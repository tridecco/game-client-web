<!DOCTYPE html>
<html lang="en">

<head>
  <%- include("../../../../partials/head.ejs") %>
  <title>Tridecco | Game Settings</title>
  <script src="<%= env.CDN_URL %>/js/multi/user.js"></script>
</head>

<body class="h-screen overflow-hidden" style="background: #8e5e4d url('<%= env.CDN_URL %>/img/backgrounds/wooden-board.jpg') center center / cover no-repeat;">
  <!-- Tridecco Background Container -->
  <div id="board-container" class="absolute top-0 left-0 w-full h-full"></div>

  <!-- Background Overlay with Blur -->
  <div class="absolute inset-0 bg-black bg-opacity-50 backdrop-filter backdrop-blur-lg"></div>

  <!-- Main Layout Container -->
  <div class="fixed inset-0 flex flex-col h-screen text-gray-800 z-20">
    <!-- Main Content Flex Container -->
    <div class="flex flex-1 w-full h-full p-3 md:p-4 gap-3 md:gap-4 overflow-hidden max-w-7xl mx-auto z-10">
      <!-- Left Sidebar: Navigation -->
      <%- include("../../../../partials/multi/navigation-bar.ejs", { page: "game-settings" }) %>

      <!-- Main Content Area -->
      <main class="flex-1 flex flex-col overflow-hidden">

        <!-- Mobile Top Bar: Back Button -->
        <header class="lg:hidden flex items-center bg-white/80 backdrop-blur-sm rounded-xl shadow-lg border border-amber-700/30 p-3 mb-3 flex-shrink-0">
          <a href="/multi/more" class="p-2 rounded-full bg-amber-100/50 hover:bg-amber-200/70 border border-amber-300/50 text-amber-700 hover:text-amber-800 transition duration-200">
            <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 19l-7-7 7-7"></path>
            </svg>
          </a>
          <span class="ml-3 text-lg font-semibold text-amber-900">Game Settings</span>
        </header>

        <section class="flex-1 bg-white/80 backdrop-blur-sm rounded-xl shadow-inner border border-amber-700/20 p-4 md:p-6 overflow-y-auto custom-scrollbar max-h-full">
          <h2 class="text-2xl font-bold mb-6 text-amber-900 hidden lg:block">Game Settings</h2>

          <!-- Skeleton Loading -->
          <div id="skeleton-loader" class="space-y-4">
            <!-- Skeleton for Volume Section -->
            <div class="space-y-4">
              <div class="w-3/4 h-4 bg-gray-300 rounded animate-pulse"></div>
              <div class="w-full h-2 bg-gray-300 rounded animate-pulse"></div>
              <div class="w-full h-2 bg-gray-300 rounded animate-pulse"></div>
            </div>

            <hr class="border-gray-300">

            <!-- Skeleton for Board Settings Section -->
            <div class="space-y-4">
              <div class="w-3/4 h-4 bg-gray-300 rounded animate-pulse"></div>
              <div class="flex flex-col md:flex-row gap-6">
                <div class="flex-grow space-y-4">
                  <div class="w-3/4 h-4 bg-gray-300 rounded animate-pulse"></div>
                  <div class="w-full h-8 bg-gray-300 rounded animate-pulse"></div>
                  <div class="w-full h-8 bg-gray-300 rounded animate-pulse"></div>
                  <div class="w-full h-8 bg-gray-300 rounded animate-pulse"></div>
                </div>
                <div class="flex-shrink-0 w-full md:w-1/3">
                  <div class="w-full h-40 bg-gray-300 rounded animate-pulse"></div>
                </div>
              </div>
            </div>

            <hr class="border-gray-300">

            <!-- Skeleton for Hotkey Settings Section -->
            <div class="space-y-4">
              <div class="w-3/4 h-4 bg-gray-300 rounded animate-pulse"></div>
              <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                <div class="w-full h-10 bg-gray-300 rounded animate-pulse"></div>
                <div class="w-full h-10 bg-gray-300 rounded animate-pulse"></div>
                <div class="w-full h-10 bg-gray-300 rounded animate-pulse"></div>
              </div>
            </div>

            <hr class="border-gray-300">
          </div>

          <!-- Settings Area -->
          <form id="settings-form" class="space-y-8 hidden">

            <!-- Volume Settings Section -->
            <div class="space-y-4">
              <h3 class="text-lg font-semibold text-amber-800 border-b border-amber-300 pb-2">Volume</h3>
              <div>
                <label for="setting-volume-bgm" class="block text-amber-800 text-sm font-bold mb-2">Background Music (<span id="volume-bgm-value">100</span>%)</label>
                <input type="range" id="setting-volume-bgm" name="game.volume.bgm" min="0" max="100" class="w-full h-2 bg-amber-200 rounded-lg appearance-none cursor-pointer range-lg dark:bg-amber-700 accent-emerald-600">
              </div>
              <div>
                <label for="setting-volume-sfx" class="block text-amber-800 text-sm font-bold mb-2">Sound Effects (<span id="volume-sfx-value">100</span>%)</label>
                <input type="range" id="setting-volume-sfx" name="game.volume.sfx" min="0" max="100" class="w-full h-2 bg-amber-200 rounded-lg appearance-none cursor-pointer range-lg dark:bg-amber-700 accent-emerald-600">
              </div>
            </div>

            <hr class="border-amber-200">

            <!-- Board Settings Section -->
            <div class="space-y-4">
              <h3 class="text-lg font-semibold text-amber-800 border-b border-amber-300 pb-2">Board Appearance</h3>
              <div class="flex flex-col md:flex-row gap-6">
                <!-- Board Options -->
                <div class="flex-grow space-y-4">
                  <div>
                    <label for="setting-board-texture" class="block text-amber-800 text-sm font-bold mb-2">Board Texture</label>
                    <select id="setting-board-texture" name="game.board.texture" class="shadow-sm appearance-none border border-amber-400 rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                      <option value="classic">Classic</option>
                    </select>
                  </div>
                  <div>
                    <label for="setting-board-colorBlindness" class="block text-amber-800 text-sm font-bold mb-2">Color Assistance</label>
                    <select id="setting-board-colorBlindness" name="game.board.colorBlindness" class="shadow-sm appearance-none border border-amber-400 rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                      <option value="none">None</option>
                      <option value="rgbblind">Red, Green, Blue</option>
                      <option value="monochrome">Monochromatic</option>
                    </select>
                  </div>
                  <div>
                    <label for="setting-board-background" class="block text-amber-800 text-sm font-bold mb-2">Game Background</label>
                    <select id="setting-board-background" name="game.board.background" class="shadow-sm appearance-none border border-amber-400 rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                      <option value="wooden-board">Wooden Board</option>
                      <option value="broken-glass">Broken Glass</option>
                      <option value="composite-board">Composite Board</option>
                      <option value="frosted-glass">Frosted Glass</option>
                      <option value="galaxy">Galaxy</option>
                      <option value="gold-leaf">Gold Leaf</option>
                      <option value="leather">Leather</option>
                      <option value="log">Log</option>
                      <option value="marble">Marble</option>
                      <option value="metal-plate">Metal Plate</option>
                      <option value="sand">Sand</option>
                    </select>
                  </div>
                  <div>
                    <label for="setting-board-grid" class="block text-amber-800 text-sm font-bold mb-2">Grid Color</label>
                    <select id="setting-board-grid" name="game.board.grid" class="shadow-sm appearance-none border border-amber-400 rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                      <option value="black">Black</option>
                      <option value="blue">Blue</option>
                      <option value="cyan">Cyan</option>
                      <option value="green">Green</option>
                      <option value="magenta">Magenta</option>
                      <option value="red">Red</option>
                      <option value="white">White</option>
                      <option value="yellow">Yellow</option>
                    </select>
                  </div>
                </div>
                <!-- Mini Board Preview -->
                <div class="flex-shrink-0 w-full md:w-1/3">
                  <label class="block text-amber-800 text-sm font-bold mb-2 text-center">Preview</label>
                  <div id="mini-board-preview" class="w-full aspect-square bg-gray-200 rounded-lg border border-amber-300 shadow-inner overflow-hidden relative">
                    <!-- Renderer Canvas will be appended here -->
                    <div id="mini-board-loading" class="absolute inset-0 flex items-center justify-center bg-gray-200 bg-opacity-75 text-amber-700 z-10">
                      Loading Preview...
                    </div>
                  </div>
                </div>
              </div>
            </div>

            <hr class="border-amber-200">

            <!-- Hotkey Settings Section -->
            <div class="space-y-4">
              <h3 class="text-lg font-semibold text-amber-800 border-b border-amber-300 pb-2">Hotkeys</h3>
              <p class="text-sm text-gray-600">Click on an input field and press the desired key to set a new hotkey.</p>
              <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                <% const hotkeys = { next: "Next", previous: "Previous", nextPiece: "Next Piece", previousPiece: "Previous Piece", confirm: "Confirm", cancel: "Cancel", trade: "Trade", accept: "Accept", refuse: "Refuse" }; %>
                <% Object.entries(hotkeys).forEach(([key, label]) => { %>
                <div>
                  <label for="setting-hotkey-<%= key %>" class="block text-amber-800 text-sm font-bold mb-1"><%= label %></label>
                  <input type="text" id="setting-hotkey-<%= key %>" name="game.hotkey.<%= key %>" readonly class="hotkey-input shadow-sm appearance-none border border-amber-400 rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-amber-500 focus:border-transparent bg-white cursor-pointer" placeholder="Press a key">
                </div>
                <% }) %>
              </div>
            </div>

            <hr class="border-amber-200">

            <!-- Save Button -->
            <div class="flex justify-end">
              <button id="save-settings" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-5 rounded-md focus:outline-none focus:shadow-outline transition duration-200 text-sm">
                Save Settings
              </button>
            </div>

          </form>

          <!-- Load Error Content -->
          <%- include("../../../../partials/multi/load-error-content.ejs") %>
        </section>

      </main>
    </div>
  </div>

  <script>
    const settingsForm = document.getElementById("settings-form");
    const skeletonLoader = document.getElementById("skeleton-loader");
    const saveSettingsButton = document.getElementById("save-settings");

    const volumeBgmSlider = document.getElementById("setting-volume-bgm");
    const volumeSfxSlider = document.getElementById("setting-volume-sfx");
    const volumeBgmValueSpan = document.getElementById("volume-bgm-value");
    const volumeSfxValueSpan = document.getElementById("volume-sfx-value");

    const boardTextureSelect = document.getElementById("setting-board-texture");
    const boardColorBlindnessSelect = document.getElementById("setting-board-colorBlindness");
    const boardBackgroundSelect = document.getElementById("setting-board-background");
    const boardGridSelect = document.getElementById("setting-board-grid");
    const miniBoardContainer = document.getElementById("mini-board-preview");
    const miniBoardLoading = document.getElementById("mini-board-loading");

    const hotkeyInputs = document.querySelectorAll(".hotkey-input");

    const loadErrorContent = document.getElementById("load-error-content");
    const retryLoadButton = document.getElementById("retry-load-button");

    let miniBoardRenderer = null;
    let initialSettings = null;

    // Initialize user module
    const user = new User(app);

    // Construct asset URLs based on settings
    function getTextureUrls(texture, colorBlindness) {
      const cbPath = colorBlindness === "none" ? "normal" : colorBlindness;
      return {
        index: `${TRIDECCO_BOARD_ASSETS_URL}/textures-bundle/${texture}/${cbPath}/index.json`,
        atlas: `${TRIDECCO_BOARD_ASSETS_URL}/textures-bundle/${texture}/${cbPath}/atlas.webp`,
      }
    }

    function getBackgroundUrl(background) {
      return `${TRIDECCO_BOARD_ASSETS_URL}/backgrounds/${background}.jpg`;
    }

    function getGridUrl(gridColor) {
      return `${TRIDECCO_BOARD_ASSETS_URL}/grids/${gridColor}.png`;
    }

    // Populate form fields with loaded settings
    function populateForm(loadedSettings) {
      if (!loadedSettings || !loadedSettings.game) return;
      const gameSettings = loadedSettings.game;

      // Volume
      if (gameSettings.volume) {
        volumeBgmSlider.value = gameSettings.volume.bgm ?? 100;
        volumeSfxSlider.value = gameSettings.volume.sfx ?? 100;
        volumeBgmValueSpan.textContent = volumeBgmSlider.value;
        volumeSfxValueSpan.textContent = volumeSfxSlider.value;
      }

      // Board
      if (gameSettings.board) {
        boardTextureSelect.value = gameSettings.board.texture ?? "classic";
        boardColorBlindnessSelect.value = gameSettings.board.colorBlindness ?? "none";
        boardBackgroundSelect.value = gameSettings.board.background ?? "wooden-board";
        boardGridSelect.value = gameSettings.board.grid ?? "black";
      }

      // Hotkeys
      if (gameSettings.hotkey) {
        hotkeyInputs.forEach(input => {
          const keyName = input.name.split(".").pop();
          const keyValue = gameSettings.hotkey[keyName] || "";
          input.value = formatKeyDisplay(keyValue);
          input.dataset.key = keyValue;
        });
      }
    }

    // Format key names for display (e.g., "ArrowRight" -> "→")
    function formatKeyDisplay(keyString) {
      if (!keyString) return "";
      const parts = keyString.split("+");
      const mainKey = parts.pop();
      const modifiers = parts;

      const map = {
        "ArrowUp": "↑",
        "ArrowDown": "↓",
        "ArrowLeft": "←",
        "ArrowRight": "→",
        " ": "Space",
        "Escape": "Esc"
      };

      const formattedMainKey = map[mainKey] || mainKey;
      return [...modifiers, formattedMainKey].join("+");
    }

    function isDuplicateHotkey(hotkeyString, currentInput) {
      if (!hotkeyString) return false;
      for (const otherInput of hotkeyInputs) {
        if (otherInput !== currentInput && otherInput.dataset.key === hotkeyString) {
          return true; // Found duplicate in another input field
        }
      }
      return false;
    }

    // Initialize the mini-board renderer
    function initializeMiniBoard(boardSettings) {
      miniBoardLoading.style.display = "flex";
      if (miniBoardRenderer) {
        try {
          miniBoardRenderer.destroy();
        } catch (e) {
          console.error("Error destroying previous renderer:", e);
        }
        miniBoardRenderer = null;
      }

      try {
        const dummyBoard = new Tridecco.Board();
        const Piece = Tridecco.Piece;
        const rendererMap = Tridecco.maps.renderer.default;
        const textureUrls = getTextureUrls(boardSettings.texture, boardSettings.colorBlindness);
        const backgroundUrl = getBackgroundUrl(boardSettings.background);
        const gridUrl = getGridUrl(boardSettings.grid);

        miniBoardRenderer = new Tridecco.Renderer({
          board: dummyBoard,
          container: miniBoardContainer,
          texturesIndexUrl: textureUrls.index,
          texturesAtlasUrl: textureUrls.atlas,
          backgroundUrl: backgroundUrl,
          gridUrl: gridUrl,
        }, () => {
          const pieceColorList = [
            ["blue", "white"],
            ["red", "blue"],
            ["red", "yellow"],
            ["white", "red"],
            ["yellow", "blue"]
          ];

          // Fill the board initially
          for (let i = 0; i < 63; i++) {
            const colorPair = pieceColorList[Math.floor(Math.random() * pieceColorList.length)];
            const piece = new Piece(colorPair);
            dummyBoard.place(i, piece);
          }

          miniBoardLoading.style.display = "none";
        });
      } catch (error) {
        console.error("Error creating Mini Board Renderer:", error);
        miniBoardLoading.style.display = "flex";
        miniBoardLoading.textContent = "Preview Error";
        app.ui.alert("Error creating board preview.", "error", 5000);
      }
    }

    // Update mini-board preview based on current selections
    async function updateMiniBoardPreview() {
      const texture = boardTextureSelect.value;
      const colorBlindness = boardColorBlindnessSelect.value;
      const background = boardBackgroundSelect.value;
      const grid = boardGridSelect.value;

      const textureUrls = getTextureUrls(texture, colorBlindness);
      const backgroundUrl = getBackgroundUrl(background);
      const gridUrl = getGridUrl(grid);

      miniBoardLoading.style.display = "flex";
      miniBoardLoading.textContent = "Updating Preview...";

      try {
        await miniBoardRenderer.updateTextures(textureUrls.index, textureUrls.atlas); // TODO: Fix the issue that cannot update textures
        await miniBoardRenderer.updateBackground(backgroundUrl);
        await miniBoardRenderer.updateGrid(gridUrl);
        miniBoardLoading.style.display = "none";
      } catch (error) {
        app.ui.alert("Failed to update preview.", "warning", 3000);
        miniBoardLoading.textContent = "Update Error";
      }
    }

    // Update Volume Slider Display
    volumeBgmSlider.addEventListener("input", (event) => {
      volumeBgmValueSpan.textContent = event.target.value;
    });
    volumeSfxSlider.addEventListener("input", (event) => {
      volumeSfxValueSpan.textContent = event.target.value;
    });

    // Update Mini Board on Board Setting Change
    boardTextureSelect.addEventListener("change", updateMiniBoardPreview);
    boardColorBlindnessSelect.addEventListener("change", updateMiniBoardPreview);
    boardBackgroundSelect.addEventListener("change", () => {
      updateMiniBoardPreview();
    });
    boardGridSelect.addEventListener("change", updateMiniBoardPreview);

    // Handle Hotkey Input
    hotkeyInputs.forEach(input => {
      input.addEventListener("focus", () => {
        input.value = "Press key...";
        input.classList.add("ring-2", "ring-amber-500"); // Indicate active input
      });

      input.addEventListener("blur", (event) => {
        const relatedTarget = event.relatedTarget;
        if (!settingsForm.contains(relatedTarget)) {
          if (input.value.endsWith("...") || input.value === "Press key...") {
            input.value = formatKeyDisplay(input.dataset.key || "");
          }
        }
        input.classList.remove("ring-2", "ring-amber-500");
      });

      input.addEventListener("keydown", (event) => {
        event.preventDefault(); // Prevent typing the key character

        const key = event.key;
        const code = event.code;

        const isModifierKey = ["Control", "Shift", "Alt", "Meta"].includes(key);

        if (!isModifierKey) {
          let modifiers = [];
          if (event.ctrlKey) modifiers.push("Ctrl");
          if (event.shiftKey) modifiers.push("Shift");
          if (event.altKey) modifiers.push("Alt");
          if (event.metaKey) modifiers.push("Meta");

          // Use the actual key pressed as the main key
          const mainKey = key;
          const finalKeyString = [...modifiers.sort(), mainKey].join("+");

          if (isDuplicateHotkey(finalKeyString, input)) {
            app.ui.alert(`Hotkey "${formatKeyDisplay(finalKeyString)}" is already assigned.`, "error", 4000);
            input.value = formatKeyDisplay(input.dataset.key || ""); // Revert display
            // Keep focus, do not blur
          } else {
            input.value = formatKeyDisplay(finalKeyString);
            input.dataset.key = finalKeyString;
            input.blur(); // Set successfully, remove focus
          }
        } else {
          // Only modifier key pressed, show intermediate state
          let currentModifiers = [];
          if (event.ctrlKey) currentModifiers.push("Ctrl");
          if (event.shiftKey) currentModifiers.push("Shift");
          if (event.altKey) currentModifiers.push("Alt");
          if (event.metaKey) currentModifiers.push("Meta");
          input.value = currentModifiers.sort().join("+") + "+...";
        }
      });
    });

    // Handle Save Settings
    saveSettingsButton.addEventListener("click", async (event) => {
      event.preventDefault(); // Prevent form submission

      if (!app.online) {
        app.ui.alert(
          "You are offline. Please check your internet connection.",
          "warning",
          3000
        );
        return;
      }

      // Final duplicate check before saving
      let duplicatesFound = false;
      const currentHotkeys = {};
      const assignedValues = new Set();

      hotkeyInputs.forEach(input => {
        const keyName = input.name.split(".").pop();
        const hotkeyValue = input.dataset.key || "";
        currentHotkeys[keyName] = hotkeyValue;
        if (hotkeyValue && assignedValues.has(hotkeyValue)) {
          duplicatesFound = true;
          input.classList.add("border-red-500", "ring-red-500");
          hotkeyInputs.forEach(otherInput => {
            if (otherInput !== input && otherInput.dataset.key === hotkeyValue) {
              otherInput.classList.add("border-red-500", "ring-red-500");
            }
          });
        } else if (hotkeyValue) {
          assignedValues.add(hotkeyValue);
          input.classList.remove("border-red-500", "ring-red-500");
        } else {
          input.classList.remove("border-red-500", "ring-red-500");
        }
      });

      if (duplicatesFound) {
        app.ui.alert("Duplicate hotkeys detected. Please ensure each hotkey is unique.", "error", 5000);
        return;
      }

      saveSettingsButton.disabled = true;
      saveSettingsButton.textContent = "Saving...";

      // Gather all settings from the form into the structure expected by the API
      const newSettings = {
        game: {
          volume: {},
          board: {},
          hotkey: {}
        }
      };
      newSettings.game.volume.bgm = parseInt(volumeBgmSlider.value, 10);
      newSettings.game.volume.sfx = parseInt(volumeSfxSlider.value, 10);
      newSettings.game.board.texture = boardTextureSelect.value;
      newSettings.game.board.colorBlindness = (() => {
        switch (boardColorBlindnessSelect.value) {
          case "none":
            return "none";
          case "rgbblind":
            return "rgb";
          case "monochrome":
            return "mono";
          default:
            return "none";
        }
      })();
      newSettings.game.board.background = boardBackgroundSelect.value;
      newSettings.game.board.grid = boardGridSelect.value;
      hotkeyInputs.forEach(input => {
        const keyName = input.name.split(".").pop();
        newSettings.game.hotkey[keyName] = input.dataset.key || initialSettings?.game?.hotkey?.[keyName] || "";
      });

      // Attempt to update settings via API using the User class instance
      const response = await user.updateSettings(newSettings);

      if (response.status === "success") {
        app.ui.notification(
          "alert",
          response.message,
          "success",
          settingsForm,
          null,
          true
        );

        initialSettings = JSON.parse(JSON.stringify(newSettings));
      } else {
        app.ui.notification(
          "alert",
          response.message,
          "error",
          settingsForm,
          null,
          true
        );
      }

      saveSettingsButton.disabled = false;
      saveSettingsButton.textContent = "Save Settings";
    });

    // Load game settings
    function loadGameSettings() {
      user.getSettings().then((response) => {
        if (response.status === "success") {
          initialSettings = response.data;

          if (initialSettings.game && initialSettings.game.board && initialSettings.game.board.colorBlindness) {
            initialSettings.game.board.colorBlindness = (() => {
              switch (initialSettings.game.board.colorBlindness) {
                case "none":
                  return "none";
                case "rgb":
                  return "rgbblind";
                case "mono":
                  return "monochrome";
                default:
                  return "none";
              }
            })();
          }

          populateForm(initialSettings);

          if (initialSettings.game && initialSettings.game.board) {
            initializeMiniBoard(initialSettings.game.board);
          } else {
            miniBoardLoading.style.display = "flex";
            miniBoardLoading.textContent = "Settings Error";
          }

          skeletonLoader.classList.add("hidden");
          settingsForm.classList.remove("hidden");
          loadErrorContent.classList.add("hidden");
        } else {
          skeletonLoader.classList.add("hidden");
          settingsForm.classList.add("hidden");
          loadErrorContent.classList.remove("hidden");
        }
      }).catch(() => {
        skeletonLoader.classList.add("hidden");
        settingsForm.classList.add("hidden");
        loadErrorContent.classList.remove("hidden");
      });
    }
    loadGameSettings();

    // Retry loading settings
    retryLoadButton.addEventListener("click", () => {
      loadErrorContent.classList.add("hidden");
      settingsForm.classList.add("hidden");
      skeletonLoader.classList.remove("hidden");
      loadGameSettings();
    });
  </script>

  <%- include("../../../../partials/tridecco-board-animator.ejs") %>
</body>

</html>