<!DOCTYPE html>
<html lang="en">

<head>
  <%- include("../../components/head.ejs") %>
  <title>Tridecco | Game Settings</title>
  <script src="<%= env.CDN_URL %>/js/user.js"></script>
</head>

<body class="h-screen overflow-hidden" style="background: url('<%= env.CDN_URL %>/img/backgrounds/wooden-board.jpg') center center / cover no-repeat;">
  <!-- Tridecco Background Container -->
  <div id="board-container" class="absolute top-0 left-0 w-full h-full"></div>

  <!-- Background Overlay with Blur -->
  <div class="absolute inset-0 bg-black bg-opacity-50 backdrop-filter backdrop-blur-lg"></div>

  <!-- Centered Content Container -->
  <div class="fixed inset-0 flex items-center justify-center p-4 overflow-y-auto">
    <!-- Main Content Box -->
    <div class="bg-white bg-opacity-90 p-6 md:p-8 rounded-xl shadow-xl w-full max-w-4xl backdrop-filter backdrop-blur-md overflow-hidden flex flex-col md:flex-row max-h-[90vh]">
      <!-- Navigation Sidebar -->
      <%- include("../../components/user-sidebar.ejs", { page: "settings" }) %>

      <!-- Settings Content Area -->
      <div class="w-full md:w-3/4 lg:w-4/5 md:pl-6 overflow-y-auto" style="max-height: calc(90vh - 4rem);">
        <h2 class="text-2xl font-bold mb-6 text-amber-900">Game Settings</h2>

        <!-- Loading Indicator -->
        <div id="loading-indicator" class="text-center p-10 text-amber-700">Loading...</div>

        <!-- Settings Area -->
        <form id="settings-form" class="space-y-8 hidden">

          <!-- Volume Settings Section -->
          <div class="space-y-4">
            <h3 class="text-lg font-semibold text-amber-800 border-b border-amber-300 pb-2">Volume</h3>
            <div>
              <label for="setting-volume-bgm" class="block text-amber-800 text-sm font-bold mb-2">Background Music (<span id="volume-bgm-value">100</span>%)</label>
              <input type="range" id="setting-volume-bgm" name="game.volume.bgm" min="0" max="100" class="w-full h-2 bg-amber-200 rounded-lg appearance-none cursor-pointer range-lg dark:bg-amber-700 accent-emerald-600">
            </div>
            <div>
              <label for="setting-volume-sfx" class="block text-amber-800 text-sm font-bold mb-2">Sound Effects (<span id="volume-sfx-value">100</span>%)</label>
              <input type="range" id="setting-volume-sfx" name="game.volume.sfx" min="0" max="100" class="w-full h-2 bg-amber-200 rounded-lg appearance-none cursor-pointer range-lg dark:bg-amber-700 accent-emerald-600">
            </div>
          </div>

          <hr class="border-amber-200">

          <!-- Board Settings Section -->
          <div class="space-y-4">
            <h3 class="text-lg font-semibold text-amber-800 border-b border-amber-300 pb-2">Board Appearance</h3>
            <div class="flex flex-col md:flex-row gap-6">
              <!-- Board Options -->
              <div class="flex-grow space-y-4">
                <div>
                  <label for="setting-board-texture" class="block text-amber-800 text-sm font-bold mb-2">Board Texture</label>
                  <select id="setting-board-texture" name="game.board.texture" class="shadow-sm appearance-none border border-amber-400 rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                    <option value="classic">Classic</option>
                  </select>
                </div>
                <div>
                  <label for="setting-board-colorBlindness" class="block text-amber-800 text-sm font-bold mb-2">Color Assistance</label>
                  <select id="setting-board-colorBlindness" name="game.board.colorBlindness" class="shadow-sm appearance-none border border-amber-400 rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                    <option value="none">None</option>
                    <option value="rgbblind">Red, Green, Blue</option>
                    <option value="monochrome">Monochromatic</option>
                  </select>
                </div>
                <div>
                  <label for="setting-board-background" class="block text-amber-800 text-sm font-bold mb-2">Game Background</label>
                  <select id="setting-board-background" name="game.board.background" class="shadow-sm appearance-none border border-amber-400 rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                    <option value="wooden-board">Wooden Board</option>
                    <option value="broken-glass">Broken Glass</option>
                    <option value="composite-board">Composite Board</option>
                    <option value="frosted-glass">Frosted Glass</option>
                    <option value="galaxy">Galaxy</option>
                    <option value="gold-leaf">Gold Leaf</option>
                    <option value="leather">Leather</option>
                    <option value="log">Log</option>
                    <option value="marble">Marble</option>
                    <option value="metal-plate">Metal Plate</option>
                    <option value="sand">Sand</option>
                  </select>
                </div>
                <div>
                  <label for="setting-board-grid" class="block text-amber-800 text-sm font-bold mb-2">Grid Color</label>
                  <select id="setting-board-grid" name="game.board.grid" class="shadow-sm appearance-none border border-amber-400 rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-amber-500 focus:border-transparent">
                    <option value="black">Black</option>
                    <option value="blue">Blue</option>
                    <option value="cyan">Cyan</option>
                    <option value="green">Green</option>
                    <option value="magenta">Magenta</option>
                    <option value="red">Red</option>
                    <option value="white">White</option>
                    <option value="yellow">Yellow</option>
                  </select>
                </div>
              </div>
              <!-- Mini Board Preview -->
              <div class="flex-shrink-0 w-full md:w-1/3">
                <label class="block text-amber-800 text-sm font-bold mb-2 text-center">Preview</label>
                <div id="mini-board-preview" class="w-full aspect-square bg-gray-200 rounded-lg border border-amber-300 shadow-inner overflow-hidden relative">
                  <!-- Renderer Canvas will be appended here -->
                  <div id="mini-board-loading" class="absolute inset-0 flex items-center justify-center bg-gray-200 bg-opacity-75 text-amber-700 z-10">
                    Loading Preview...
                  </div>
                </div>
              </div>
            </div>
          </div>

          <hr class="border-amber-200">

          <!-- Hotkey Settings Section -->
          <div class="space-y-4">
            <h3 class="text-lg font-semibold text-amber-800 border-b border-amber-300 pb-2">Hotkeys</h3>
            <p class="text-sm text-gray-600">Click on an input field and press the desired key to set a new hotkey.</p>
            <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
              <% const hotkeys = { next: 'Next', previous: 'Previous', nextPiece: 'Next Piece', previousPiece: 'Previous Piece', confirm: 'Confirm', cancel: 'Cancel', trade: 'Trade', accept: 'Accept', refuse: 'Refuse' }; %>
              <% Object.entries(hotkeys).forEach(([key, label]) => { %>
              <div>
                <label for="setting-hotkey-<%= key %>" class="block text-amber-800 text-sm font-bold mb-1"><%= label %></label>
                <input type="text" id="setting-hotkey-<%= key %>" name="game.hotkey.<%= key %>" readonly class="hotkey-input shadow-sm appearance-none border border-amber-400 rounded w-full py-2 px-3 text-gray-700 leading-tight focus:outline-none focus:ring-2 focus:ring-amber-500 focus:border-transparent bg-white cursor-pointer" placeholder="Press a key">
              </div>
              <% }) %>
            </div>
          </div>

          <hr class="border-amber-200">

          <!-- Save Button -->
          <div class="flex justify-end">
            <button id="save-settings" class="bg-emerald-600 hover:bg-emerald-700 text-white font-bold py-2 px-5 rounded-md focus:outline-none focus:shadow-outline transition duration-200 text-sm">
              Save Settings
            </button>
          </div>

        </form>
      </div>
    </div>
  </div>

  <!-- Include Tridecco Animator -->
  <%- include("../../components/tridecco-board-animator.ejs") %>

  <script>
    const loadingIndicator = document.getElementById("loading-indicator");
    const settingsForm = document.getElementById("settings-form");
    const saveSettingsButton = document.getElementById("save-settings");

    const volumeBgmSlider = document.getElementById("setting-volume-bgm");
    const volumeSfxSlider = document.getElementById("setting-volume-sfx");
    const volumeBgmValueSpan = document.getElementById("volume-bgm-value");
    const volumeSfxValueSpan = document.getElementById("volume-sfx-value");

    const boardTextureSelect = document.getElementById("setting-board-texture");
    const boardColorBlindnessSelect = document.getElementById("setting-board-colorBlindness");
    const boardBackgroundSelect = document.getElementById("setting-board-background");
    const boardGridSelect = document.getElementById("setting-board-grid");
    const miniBoardContainer = document.getElementById("mini-board-preview");
    const miniBoardLoading = document.getElementById("mini-board-loading");

    const hotkeyInputs = document.querySelectorAll(".hotkey-input");

    let miniBoardRenderer = null;
    let initialSettings = null;

    // Initialize user module
    const user = new User(app);

    // Construct asset URLs based on settings
    function getTextureUrl(texture, colorBlindness) {
      const cbPath = colorBlindness === 'none' ? 'normal' : colorBlindness;
      return `${TRIDECCO_BOARD_ASSETS_URL}/textures/${texture}/${cbPath}`;
    }

    function getBackgroundUrl(background) {
      return `${TRIDECCO_BOARD_ASSETS_URL}/backgrounds/${background}.jpg`;
    }

    function getGridUrl(gridColor) {
      return `${TRIDECCO_BOARD_ASSETS_URL}/grids/${gridColor}.png`;
    }

    // Populate form fields with loaded settings
    function populateForm(loadedSettings) {
      if (!loadedSettings || !loadedSettings.game) return;
      const gameSettings = loadedSettings.game;

      // Volume
      if (gameSettings.volume) {
        volumeBgmSlider.value = gameSettings.volume.bgm ?? 100;
        volumeSfxSlider.value = gameSettings.volume.sfx ?? 100;
        volumeBgmValueSpan.textContent = volumeBgmSlider.value;
        volumeSfxValueSpan.textContent = volumeSfxSlider.value;
      }

      // Board
      if (gameSettings.board) {
        boardTextureSelect.value = gameSettings.board.texture ?? 'classic';
        boardColorBlindnessSelect.value = gameSettings.board.colorBlindness ?? 'none';
        boardBackgroundSelect.value = gameSettings.board.background ?? 'wooden-board';
        boardGridSelect.value = gameSettings.board.grid ?? 'black';
      }

      // Hotkeys
      if (gameSettings.hotkey) {
        hotkeyInputs.forEach(input => {
          const keyName = input.name.split('.').pop();
          if (gameSettings.hotkey[keyName]) {
            input.value = formatKeyDisplay(gameSettings.hotkey[keyName]);
            input.dataset.key = gameSettings.hotkey[keyName];
          } else {
            input.value = '';
            input.dataset.key = '';
          }
        });
      }
    }

    // Format key names for display (e.g., 'ArrowRight' -> '→')
    function formatKeyDisplay(key) {
      if (!key) return ''; // Handle empty key
      const map = {
        'ArrowUp': '↑',
        'ArrowDown': '↓',
        'ArrowLeft': '←',
        'ArrowRight': '→',
        ' ': 'Space',
        'Escape': 'Esc'
      };
      return map[key] || key; // Use mapped value or original key
    }

    // Initialize the mini-board renderer
    function initializeMiniBoard(boardSettings) {
      miniBoardLoading.style.display = 'flex';
      if (miniBoardRenderer) {
        try {
          miniBoardRenderer.destroy();
        } catch (e) {
          console.error("Error destroying previous renderer:", e);
        }
        miniBoardRenderer = null;
      }

      if (!Tridecco || !Tridecco.Board || !Tridecco.Renderer || !Tridecco.Piece) {
        console.error("Tridecco library not loaded correctly.");
        miniBoardLoading.textContent = "Preview Error";
        app.ui.alert("Failed to load board preview library.", "error", 5000);
        return;
      }

      try {
        // Create a minimal dummy board instance for rendering
        const dummyBoard = new Tridecco.Board();
        const Piece = Tridecco.Piece;

        const textureUrl = getTextureUrl(boardSettings.texture, boardSettings.colorBlindness);
        const backgroundUrl = getBackgroundUrl(boardSettings.background);
        const gridUrl = getGridUrl(boardSettings.grid);

        miniBoardRenderer = new Tridecco.Renderer({
          board: dummyBoard,
          container: miniBoardContainer,
          texturesUrl: textureUrl,
          backgroundUrl: backgroundUrl,
          gridUrl: gridUrl,
        }, () => {
          const pieceColorList = [
            ['blue', 'white'],
            ['red', 'blue'],
            ['red', 'yellow'],
            ['white', 'red'],
            ['yellow', 'blue']
          ];

          // Fill the board initially
          for (let i = 0; i < 63; i++) {
            const colorPair = pieceColorList[Math.floor(Math.random() * pieceColorList.length)];
            const piece = new Piece(colorPair);
            dummyBoard.place(i, piece);
          }

          miniBoardLoading.style.display = 'none';
        });
      } catch (error) {
        console.error("Error creating Mini Board Renderer:", error);
        miniBoardLoading.style.display = 'flex';
        miniBoardLoading.textContent = "Preview Error";
        app.ui.alert("Error creating board preview.", "error", 5000);
      }
    }

    // Update mini-board preview based on current selections
    async function updateMiniBoardPreview() {
      const texture = boardTextureSelect.value;
      const colorBlindness = boardColorBlindnessSelect.value;
      const background = boardBackgroundSelect.value;
      const grid = boardGridSelect.value;

      const textureUrl = getTextureUrl(texture, colorBlindness);
      const backgroundUrl = getBackgroundUrl(background);
      const gridUrl = getGridUrl(grid);

      miniBoardLoading.style.display = 'flex';
      miniBoardLoading.textContent = 'Updating Preview...';

      try {
        await miniBoardRenderer.updateTextures(textureUrl);
        await miniBoardRenderer.updateBackground(backgroundUrl);
        await miniBoardRenderer.updateGrid(gridUrl);
        miniBoardLoading.style.display = 'none';
      } catch (error) {
        app.ui.alert("Failed to update preview.", "warning", 3000);
        miniBoardLoading.textContent = "Update Error";
      }
    }

    // Update Volume Slider Display
    volumeBgmSlider.addEventListener("input", (event) => {
      volumeBgmValueSpan.textContent = event.target.value;
    });
    volumeSfxSlider.addEventListener("input", (event) => {
      volumeSfxValueSpan.textContent = event.target.value;
    });

    // Update Mini Board on Board Setting Change
    boardTextureSelect.addEventListener("change", updateMiniBoardPreview);
    boardColorBlindnessSelect.addEventListener("change", updateMiniBoardPreview);
    boardBackgroundSelect.addEventListener("change", () => {
      updateMiniBoardPreview();
    });
    boardGridSelect.addEventListener("change", updateMiniBoardPreview);

    // Handle Hotkey Input
    hotkeyInputs.forEach(input => {
      input.addEventListener('focus', () => {
        input.value = 'Press key...';
        input.classList.add('ring-2', 'ring-amber-500'); // Indicate active input
      });

      input.addEventListener('blur', () => {
        if (input.value === 'Press key...') {
          input.value = formatKeyDisplay(input.dataset.key || '');
        }
        input.classList.remove('ring-2', 'ring-amber-500');
      });

      input.addEventListener('keydown', (event) => {
        event.preventDefault(); // Prevent typing the key character

        const key = event.key;
        const code = event.code;

        // Basic validation: Don't allow modifier keys alone (Shift, Ctrl, Alt, Meta)
        if (['Shift', 'Control', 'Alt', 'Meta'].includes(key)) {
          input.value = formatKeyDisplay(input.dataset.key || ''); // Revert to old value
          app.ui.alert('Modifier keys (Shift, Ctrl, Alt) cannot be used alone as hotkeys.', 'warning', 3000);
          return;
        }

        input.value = formatKeyDisplay(key);
        input.dataset.key = key;
        input.blur(); // Remove focus after setting
      });
    });

    // Handle Save Settings
    saveSettingsButton.addEventListener("click", async (event) => {
      event.preventDefault(); // Prevent form submission

      if (!app.online) {
        app.ui.alert(
          "You are offline. Please check your internet connection.",
          "warning",
          3000
        );
        return;
      }

      saveSettingsButton.disabled = true;
      saveSettingsButton.textContent = 'Saving...';

      // Gather all settings from the form into the structure expected by the API
      const newSettings = {
        game: {
          volume: {},
          board: {},
          hotkey: {}
        }
      };
      newSettings.game.volume.bgm = parseInt(volumeBgmSlider.value, 10);
      newSettings.game.volume.sfx = parseInt(volumeSfxSlider.value, 10);
      newSettings.game.board.texture = boardTextureSelect.value;
      newSettings.game.board.colorBlindness = (() => {
        switch (boardColorBlindnessSelect.value) {
          case 'none':
            return 'none';
          case 'rgbblind':
            return 'rgb';
          case 'monochrome':
            return 'mono';
          default:
            return 'none';
        }
      })();
      newSettings.game.board.background = boardBackgroundSelect.value;
      newSettings.game.board.grid = boardGridSelect.value;
      hotkeyInputs.forEach(input => {
        const keyName = input.name.split('.').pop();
        newSettings.game.hotkey[keyName] = input.dataset.key || initialSettings?.game?.hotkey?.[keyName] || '';
      });

      // Attempt to update settings via API using the User class instance
      const response = await user.updateSettings(newSettings);

      if (response.status === "success") {
        app.ui.notification(
          "alert",
          response.message,
          "success",
          settingsForm,
          null,
          true
        );

        initialSettings = JSON.parse(JSON.stringify(newSettings));
      } else {
        app.ui.notification(
          "alert",
          response.message,
          "error",
          settingsForm,
          null,
          true
        );
      }

      saveSettingsButton.disabled = false;
      saveSettingsButton.textContent = 'Save Settings';
    });

    // Initialize the mini-board renderer and load settings on page load
    document.addEventListener("DOMContentLoaded", async () => {
      const response = await user.getSettings();

      if (response.status === "success") {
        initialSettings = response.data;

        if (initialSettings.game && initialSettings.game.board && initialSettings.game.board.colorBlindness) {
          initialSettings.game.board.colorBlindness = (() => {
            switch (initialSettings.game.board.colorBlindness) {
              case 'none':
                return 'none';
              case 'rgb':
                return 'rgbblind';
              case 'mono':
                return 'monochrome';
              default:
                return 'none';
            }
          })();
        }

        populateForm(initialSettings);

        if (initialSettings.game && initialSettings.game.board) {
          initializeMiniBoard(initialSettings.game.board);
        } else {
          miniBoardLoading.style.display = 'flex';
          miniBoardLoading.textContent = "Settings Error";
        }

        loadingIndicator.classList.add("hidden");
        settingsForm.classList.remove("hidden");
      }
    });
  </script>
</body>

</html>